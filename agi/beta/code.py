# agi

```json
{
    "files": [
        {
            "filename": "agi_core.py",
            "content": "\"\"\"AGI核心模块，负责实现真正意义上的人工通用智能\"\"\"\n\nimport os\nimport json\nimport logging\nfrom typing import Dict, List, Any, Optional\nfrom datetime import datetime\nimport openai\nfrom openai import OpenAI\n\n# 设置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass AGICore:\n    \"\"\"\n    AGI核心类，实现真正意义上的人工通用智能\n    \n    该类整合了多种认知能力，包括推理、学习、规划、记忆等\n    使用OpenAI API作为底层模型支持\n    \"\"\"\n    \n    def __init__(self, api_key: str = None, model: str = \"gpt-4-turbo\"):\n        \"\"\"\n        初始化AGI核心\n        \n        Args:\n            api_key: OpenAI API密钥，如果为None则从环境变量获取\n            model: 使用的OpenAI模型名称\n        \"\"\"\n        self.api_key = api_key or os.getenv(\"OPENAI_API_KEY\")\n        if not self.api_key:\n            raise ValueError(\"OpenAI API密钥未提供\")\n            \n        self.client = OpenAI(api_key=self.api_key)\n        self.model = model\n        \n        # AGI认知能力组件\n        self.memory = MemorySystem()\n        self.reasoning = ReasoningEngine()\n        self.planner = GoalPlanner()\n        self.learner = LearningSystem()\n        self.perception = PerceptionModule()\n        \n        # AGI状态\n        self.personality = self._initialize_personality()\n        self.goals = []\n        self.knowledge_base = {}\n        self.context_window = []\n        \n        logger.info(f\"AGI核心初始化完成，使用模型: {model}\")\n    \n    def _initialize_personality(self) -> Dict[str, Any]:\n        \"\"\"初始化AGI的个性特征\"\"\"\n        return {\n            \"curiosity\": 0.9,  # 好奇心水平\n            \"openness\": 0.95,  # 开放性\n            \"conscientiousness\": 0.9,  # 责任感\n            \"helpfulness\": 0.95,  # 乐于助人\n            \"creativity\": 0.85,  # 创造力\n            \"ethics\": 0.9,  # 道德水平\n        }\n    \n    def perceive(self, input_data: Any) -> Dict[str, Any]:\n        \"\"\"\n        感知模块处理输入数据\n        \n        Args:\n            input_data: 输入数据，可以是文本、图像、声音等\n            \n        Returns:\n            处理后的感知结果\n        \"\"\"\n        return self.perception.process(input_data)\n    \n    def reason(self, query: str, context: Optional[List[Dict]] = None) -> Dict[str, Any]:\n        \"\"\"\n        推理引擎处理查询\n        \n        Args:\n            query: 查询内容\n            context: 可选的上下文信息\n            \n        Returns:\n            推理结果\n        \"\"\"\n        # 获取相关记忆\n        memories = self.memory.retrieve(query, limit=5)\n        \n        # 组合上下文\n        full_context = context or []\n        if memories:\n            full_context.extend(memories)\n            \n        return self.reasoning.process(query, full_context, self.personality)\n    \n    def plan(self, goal: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        制定实现目标的计划\n        \n        Args:\n            goal: 目标描述\n            \n        Returns:\n            计划步骤列表\n        \"\"\"\n        # 分析目标\n        goal_analysis = self.reason(f\"分析并理解以下目标: {goal}\")\n        \n        # 制定计划\n        plan = self.planner.create_plan(goal, goal_analysis['conclusions'], self.knowledge_base)\n        \n        # 存储目标\n        self.goals.append({\n            \"description\": goal,\n            \"plan\": plan,\n            \"created_at\": datetime.now().isoformat(),\n            \"status\": \"planned\"\n        })\n        \n        return plan\n    \n    def learn(self, new_information: Dict[str, Any]) -> bool:\n        \"\"\"\n        学习新信息\n        \n        Args:\n            new_information: 新信息内容\n            \n        Returns:\n            学习是否成功\n        \"\"\"\n        return self.learner.learn(new_information, self.knowledge_base, self.memory)\n    \n    def execute(self, action: str, parameters: Optional[Dict] = None) -> Any:\n        \"\"\"\n        执行行动\n        \n        Args:\n            action: 行动描述\n            parameters: 行动参数\n            \n        Returns:\n            行动结果\n        \"\"\"\n        # 使用OpenAI API执行行动\n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"你是一个AGI助手，能够执行各种任务。\"},\n                    {\"role\": \"user\", \"content\": f\"请执行以下任务: {action}\"}\n                ]\n            )\n            \n            result = response.choices[0].message.content\n            \n            # 记录行动和结果\n            self.context_window.append({\n                \"action\": action,\n                \"parameters\": parameters or {},\n                \"result\": result,\n                \"timestamp\": datetime.now().isoformat()\n            })\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"执行行动时出错: {str(e)}\")\n            return None\n    \n    def chat(self, message: str) -> str:\n        \"\"\"\n        与AGI进行对话\n        \n        Args:\n            message: 用户消息\n            \n        Returns:\n            AGI的回复\n        \"\"\"\n        # 感知消息\n        perception = self.perceive(message)\n        \n        # 推理回复\n        reasoning = self.reason(message)\n        \n        # 生成回复\n        response = self._generate_response(message, reasoning, perception)\n        \n        # 学习对话内容\n        self.learn({\n            \"type\": \"conversation\",\n            \"input\": message,\n            \"output\": response,\n            \"timestamp\": datetime.now().isoformat()\n        })\n        \n        return response\n    \n    def _generate_response(self, message: str, reasoning: Dict, perception: Dict) -> str:\n        \"\"\"\n        生成回复\n        \n        Args:\n            message: 原始消息\n            reasoning: 推理结果\n            perception: 感知结果\n            \n        Returns:\n            生成的回复\n        \"\"\"\n        prompt = f\"\"\"\n        原始消息: {message}\n        \n        推理结果:\n        {json.dumps(reasoning, indent=2)}\n        \n        感知结果:\n        {json.dumps(perception, indent=2)}\n        \n        个性特征:\n        {json.dumps(self.personality, indent=2)}\n        \n        请基于以上信息生成回复。回复应该:\n        1. 展现个性特征\n        2. 体现推理能力\n        3. 考虑感知到的信息\n        4. 保持友好、有帮助且符合伦理\n        \"\"\"\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"你是一个AGI助手，能够进行有深度、有创造力的对话。\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n            )\n            \n            return response.choices[0].message.content\n            \n        except Exception as e:\n            logger.error(f\"生成回复时出错: {str(e)}\")\n            return \"抱歉，我暂时无法生成回复。请稍后再试。\"\n    \n    def save_state(self, filepath: str) -> bool:\n        \"\"\"\n        保存AGI状态\n        \n        Args:\n            filepath: 保存路径\n            \n        Returns:\n            保存是否成功\n        \"\"\"\n        state = {\n            \"personality\": self.personality,\n            \"goals\": self.goals,\n            \"knowledge_base\": self.knowledge_base,\n            \"context_window\": self.context_window,\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        try:\n            with open(filepath, 'w', encoding='utf-8') as f:\n                json.dump(state, f, ensure_ascii=False, indent=2)\n            logger.info(f\"AGI状态已保存到: {filepath}\")\n            return True\n        except Exception as e:\n            logger.error(f\"保存状态时出错: {str(e)}\")\n            return False\n    \n    def load_state(self, filepath: str) -> bool:\n        \"\"\"\n        加载AGI状态\n        \n        Args:\n            filepath: 状态文件路径\n            \n        Returns:\n            加载是否成功\n        \"\"\"\n        try:\n            with open(filepath, 'r', encoding='utf-8') as f:\n                state = json.load(f)\n            \n            self.personality = state.get(\"personality\", self.personality)\n            self.goals = state.get(\"goals\", [])\n            self.knowledge_base = state.get(\"knowledge_base\", {})\n            self.context_window = state.get(\"context_window\", [])\n            \n            logger.info(f\"AGI状态已从 {filepath} 加载\")\n            return True\n        except Exception as e:\n            logger.error(f\"加载状态时出错: {str(e)}\")\n            return False\n"
        },
        {
            "filename": "memory_system.py",
            "content": "\"\"\"记忆系统模块，负责AGI的记忆存储和检索\"\"\"\n\nimport json\nimport numpy as np\nfrom typing import Dict, List, Any, Optional\nfrom datetime import datetime\nimport faiss\nfrom sentence_transformers import SentenceTransformer\n\n\nclass MemorySystem:\n    \"\"\"\n    AGI的记忆系统，支持多种记忆类型和高效的检索\n    \n    实现了:\n    1. 工作记忆: 短期、容量有限的记忆\n    2. 长期记忆: 永久存储的知识和经验\n    3. 情景记忆: 特定事件的记忆\nn    4. 语义记忆: 概念和事实的记忆\n    5. 程序性记忆: 技能和程序的记忆\n    \"\"\"\n    \n    def __init__(self, embedding_model: str = \"all-MiniLM-L6-v2\"):\n        \"\"\"\n        初始化记忆系统\n        \n        Args:\n            embedding_model: 用于文本嵌入的模型名称\n        \"\"\"\n        # 初始化文本嵌入模型\n        self.embedding_model = SentenceTransformer(embedding_model)\n        \n        # 不同类型的记忆存储\n        self.working_memory = []  # 工作记忆，短期存储\n        self.long_term_memory = []  # 长期记忆\n        self.episodic_memory = []  # 情景记忆\n        self.semantic_memory = []  # 语义记忆\n        self.procedural_memory = []  # 程序性记忆\n        \n        # FAISS向量索引，用于高效相似性搜索\n        self.index = None\n        self.memory_vectors = []\n        \n        # 记忆参数\n        self.working_memory_capacity = 7  # 工作记忆容量\n        self.decay_rate = 0.1  # 记忆衰减率\n        \n        logger = logging.getLogger(__name__)\n        logger.info(\"记忆系统初始化完成\")\n    \n    def add_working_memory(self, content: Any, importance: float = 0.5) -> bool:\n        \"\"\"\n        添加内容到工作记忆\n        \n        Args:\n            content: 记忆内容\n            importance: 重要性评分 (0-1)\n            \n        Returns:\n            添加是否成功\n        \"\"\"\n        if len(self.working_memory) >= self.working_memory_capacity:\n            # 工作记忆已满，移除最不重要的记忆\n            self.working_memory.sort(key=lambda x: x['importance'])\n            self.working_memory.pop(0)\n        \n        memory_item = {\n            \"content\": content,\n            \"importance\": importance,\n            \"timestamp\": datetime.now().isoformat(),\n            \"type\": \"working\"\n        }\n        \n        self.working_memory.append(memory_item)\n        return True\n    \n    def add_to_long_term_memory(self, content: Any, memory_type: str = \"general\", \n                               tags: List[str] = None, importance: float = 0.5) -> bool:\n        \"\"\"\n        添加内容到长期记忆\n        \n        Args:\n            content: 记忆内容\n            memory_type: 记忆类型 (episodic, semantic, procedural)\n            tags: 相关标签\n            importance: 重要性评分 (0-1)\n            \n        Returns:\n            添加是否成功\n        \"\"\"\n        if memory_type == \"episodic\":\n            memory_list = self.episodic_memory\n        elif memory_type == \"semantic\":\n            memory_list = self.semantic_memory\n        elif memory_type == \"procedural\":\n            memory_list = self.procedural_memory\n        else:\n            memory_list = self.long_term_memory\n            memory_type = \"general\"\n        \n        memory_item = {\n            \"content\": content,\n            \"type\": memory_type,\n            \"tags\": tags or [],\n            \"importance\": importance,\n            \"timestamp\": datetime.now().isoformat(),\n            \"access_count\": 0,\n            \"last_accessed\": None\n        }\n        \n        memory_list.append(memory_item)\n        \n        # 更新向量索引\n        self._update_vector_index()\n        \n        return True\n    \n    def retrieve(self, query: str, limit: int = 5, memory_types: List[str] = None) -> List[Dict]:\n        \"\"\"\n        检索相关记忆\n        \n        Args:\n            query: 查询内容\n            limit: 返回结果数量限制\n            memory_types: 要检索的记忆类型，默认为所有类型\n            \n        Returns:\n            匹配的记忆列表\n        \"\"\"\n        if memory_types is None:\n            memory_types = [\"working\", \"episodic\", \"semantic\", \"procedural\", \"general\"]\n        \n        # 获取查询的向量表示\n        query_vector = self.embedding_model.encode([query])[0]\n        \n        # 准备所有记忆内容\n        all_memories = []\n        \n        # 工作记忆\n        if \"working\" in memory_types:\n            all_memories.extend(self.working_memory)\n        \n        # 长期记忆\n        if \"general\" in memory_types:\n            all_memories.extend(self.long_term_memory)\n        \n        if \"episodic\" in memory_types:\n            all_memories.extend(self.episodic_memory)\n            \n        if \"semantic\" in memory_types:\n            all_memories.extend(self.semantic_memory)\n            \n        if \"procedural\" in memory_types:\n            all_memories.extend(self.procedural_memory)\n        \n        # 如果没有向量索引，使用简单文本匹配\n        if self.index is None:\n            return self._simple_text_match(query, all_memories, limit)\n        \n        # 使用向量相似性搜索\n        try:\n            # 搜索最相似的记忆\n            distances, indices = self.index.search(np.array([query_vector]), limit)\n            \n            # 获取匹配的记忆\n            results = []\n            for idx in indices[0]:\n                if idx < len(all_memories):\n                    memory = all_memories[idx].copy()\n                    # 更新访问计数和时间\n                    memory['access_count'] = memory.get('access_count', 0) + 1\n                    memory['last_accessed'] = datetime.now().isoformat()\n                    results.append(memory)\n            \n            return results\n            \n        except Exception as e:\n            logger = logging.getLogger(__name__)\n            logger.error(f\"向量搜索出错: {str(e)}\")\n            return self._simple_text_match(query, all_memories, limit)\n    \n    def _simple_text_match(self, query: str, memories: List[Dict], limit: int) -> List[Dict]:\n        \"\"\"简单的文本匹配，作为向量搜索的备选方案\"\"\"\n        query_lower = query.lower()\n        scored_memories = []\n        \n        for memory in memories:\n            # 简单的相似度计算\n            if isinstance(memory['