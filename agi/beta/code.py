# agi

```json
{
    "files": [
        {
            "filename": "agi_system.py",
            "content": "\"\"\"AGI System - A framework for developing artificial general intelligence.\n\nThis module provides the core infrastructure for building an AGI system using OpenAI's APIs.\nIt includes components for memory, reasoning, learning, and decision-making.\n\"\"\"\n\nimport os\nimport json\nimport time\nimport logging\nfrom typing import Dict, List, Any, Optional\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nimport openai\nfrom openai import OpenAI\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass Memory:\n    \"\"\"Stores and manages the system's memories and experiences.\"\"\"\n    memories: List[Dict[str, Any]] = field(default_factory=list)\n    \n    def add_memory(self, content: str, metadata: Optional[Dict[str, Any]] = None) -> None:\n        \"\"\"Add a new memory to the system.\"\"\"\n        memory = {\n            \"id\": len(self.memories) + 1,\n            \"content\": content,\n            \"timestamp\": datetime.now().isoformat(),\n            \"metadata\": metadata or {}\n        }\n        self.memories.append(memory)\n        logger.info(f\"Added memory {memory['id']}: {content[:50]}...\")\n    \n    def retrieve_memories(self, query: str, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"Retrieve relevant memories based on a query.\"\"\"\n        # In a real implementation, this would use vector search\n        # For now, we'll use a simple keyword match\n        relevant = []\n        for memory in self.memories:\n            if query.lower() in memory[\"content\"].lower():\n                relevant.append(memory)\n            if len(relevant) >= limit:\n                break\n        return relevant\n\n\n@dataclass\nclass ReasoningEngine:\n    \"\"\"Handles logical reasoning and problem-solving.\"\"\"\n    client: OpenAI\n    \n    def reason(self, problem: str, context: List[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Reason about a problem using available context.\"\"\"\n        context_text = \"\\n\".join([mem[\"content\"] for mem in (context or [])])\n        \n        prompt = f\"\"\"You are an advanced reasoning AI. Analyze the following problem and provide a reasoned response.\n\nProblem: {problem}\n\nContext:\n{context_text}\n\nProvide your reasoning in JSON format with the following keys:\n- \"analysis\": A step-by-step analysis of the problem\n- \"conclusion\": Your conclusion based on the analysis\n- \"confidence\": A confidence score from 0 to 1\n- \"next_steps\": Suggested next steps\n\"\"\"\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                temperature=0.2,\n                response_format={\"type\": \"json_object\"}\n            )\n            \n            result = json.loads(response.choices[0].message.content)\n            return result\n        except Exception as e:\n            logger.error(f\"Error during reasoning: {str(e)}\")\n            return {\n                \"analysis\": \"Error occurred during reasoning.\",\n                \"conclusion\": \"Unable to reach a conclusion.\",\n                \"confidence\": 0.0,\n                \"next_steps\": [\"Retry reasoning\", \"Simplify problem\"]\n            }\n\n\n@dataclass\nclass LearningModule:\n    \"\"\"Handles learning and adaptation based on new experiences.\"\"\"\n    client: OpenAI\n    \n    def learn_from_experience(self, experience: Dict[str, Any], feedback: Optional[str] = None) -> None:\n        \"\"\"Learn from an experience and optional feedback.\"\"\"\n        prompt = f\"\"\"You are an AI learning system. Analyze the following experience and extract learning points.\n\nExperience: {json.dumps(experience, indent=2)}\n\nFeedback: {feedback or \"No feedback provided.\"}\n\nProvide your analysis in JSON format with the following keys:\n- \"insights\": Key insights gained from the experience\n- \"improvements\": Suggestions for improvement\n- \"generalizations\": General principles that can be applied to similar situations\n\"\"\"\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                temperature=0.2,\n                response_format={\"type\": \"json_object\"}\n            )\n            \n            learning = json.loads(response.choices[0].message.content)\n            logger.info(f\"Learning from experience: {learning}\")\n            return learning\n        except Exception as e:\n            logger.error(f\"Error during learning: {str(e)}\")\n            return None\n\n\n@dataclass\nclass DecisionMaker:\n    \"\"\"Makes decisions based on reasoning and goals.\"\"\"\n    client: OpenAI\n    \n    def make_decision(self, situation: str, goals: List[str], options: List[str], context: List[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Make a decision based on the situation, goals, and available options.\"\"\"\n        context_text = \"\\n\".join([mem[\"content\"] for mem in (context or [])])\n        \n        prompt = f\"\"\"You are an advanced decision-making AI. Analyze the following situation and make the best decision based on the given goals and options.\n\nSituation: {situation}\n\nGoals: {', '.join(goals)}\n\nOptions: {', '.join(options)}\n\nContext:\n{context_text}\n\nProvide your decision in JSON format with the following keys:\n- \"decision\": The chosen option\n- \"reasoning\": Your reasoning for choosing this option\n- \"expected_outcome\": Expected outcome of this decision\n- \"alternatives_considered\": Other options you considered and why they were rejected\n- \"risks\": Potential risks associated with this decision\n\"\"\"\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                temperature=0.2,\n                response_format={\"type\": \"json_object\"}\n            )\n            \n            decision = json.loads(response.choices[0].message.content)\n            return decision\n        except Exception as e:\n            logger.error(f\"Error during decision making: {str(e)}\")\n            return {\n                \"decision\": \"No decision could be made\",\n                \"reasoning\": \"Error occurred during decision making process.\",\n                \"expected_outcome\": \"Unknown\",\n                \"alternatives_considered\": [],\n                \"risks\": [\"Decision making system error\"]\n            }\n\n\n@dataclass\nclass AGISystem:\n    \"\"\"The main AGI system that coordinates all components.\"\"\"\n    memory: Memory = field(default_factory=Memory)\n    reasoning_engine: Optional[ReasoningEngine] = None\n    learning_module: Optional[LearningModule] = None\n    decision_maker: Optional[DecisionMaker] = None\n    \n    def __post_init__(self):\n        # Initialize OpenAI client\n        api_key = os.getenv(\"OPENAI_API_KEY\")\n        if not api_key:\n            raise ValueError(\"OPENAI_API_KEY environment variable not set\")\n        \n        client = OpenAI(api_key=api_key)\n        \n        # Initialize components\n        self.reasoning_engine = ReasoningEngine(client=client)\n        self.learning_module = LearningModule(client=client)\n        self.decision_maker = DecisionMaker(client=client)\n    \n    def process_input(self, user_input: str) -> Dict[str, Any]:\n        \"\"\"Process user input and generate a response.\"\"\"\n        # Store the input as a memory\n        self.memory.add_memory(user_input, {\"type\": \"user_input\"})\n        \n        # Retrieve relevant memories for context\n        relevant_memories = self.memory.retrieve_memories(user_input)\n        \n        # Reason about the input\n        reasoning = self.reasoning_engine.reason(user_input, relevant_memories)\n        \n        # Generate response\n        response = self.generate_response(user_input, reasoning, relevant_memories)\n        \n        # Store the response as a memory\n        self.memory.add_memory(response[\"content\"], {\"type\": \"system_response\"})\n        \n        # Learn from the interaction\n        experience = {\n            \"input\": user_input,\n            \"reasoning\": reasoning,\n            \"response\": response\n        }\n        learning = self.learning_module.learn_from_experience(experience)\n        \n        return {\n            \"response\": response,\n            \"reasoning\": reasoning,\n            \"learning\": learning,\n            \"relevant_memories\": relevant_memories\n        }\n    \n    def generate_response(self, user_input: str, reasoning: Dict[str, Any], context: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"Generate a response to user input based on reasoning and context.\"\"\"\n        context_text = \"\\n\".join([mem[\"content\"] for mem in context])\n        \n        prompt = f\"\"\"You are an AGI system. Generate a helpful, informative response to the user input based on your reasoning and available context.\n\nUser Input: {user_input}\n\nReasoning: {json.dumps(reasoning, indent=2)}\n\nContext:\n{context_text}\n\nProvide your response in JSON format with the following keys:\n- \"content\": The actual response content\n- \"confidence\": Your confidence in this response (0-1)\n- \"clarification_needed\": Whether you need to ask for clarification\n\"\"\"\n        \n        try:\n            response = self.reasoning_engine.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                temperature=0.5,\n                response_format={\"type\": \"json_object\"}\n            )\n            \n            result = json.loads(response.choices[0].message.content)\n            return result\n        except Exception as e:\n            logger.error(f\"Error generating response: {str(e)}\")\n            return {\n                \"content\": \"I apologize, but I encountered an error while processing your request.\",\n                \"confidence\": 0.0,\n                \"clarification_needed\": False\n            }\n    \n    def make_decision(self, situation: str, goals: List[str], options: List[str]) -> Dict[str, Any]:\n        \"\"\"Make a decision based on the given situation, goals, and options.\"\"\"\n        # Retrieve relevant memories for context\n        relevant_memories = self.memory.retrieve_memories(situation)\n        \n        # Make the decision\n        decision = self.decision_maker.make_decision(situation, goals, options, relevant_memories)\n        \n        # Store the decision as a memory\n        self.memory.add_memory(\n            f\"Decision: {decision['decision']} for situation: {situation}\",\n            {\"type\": \"decision\", \"decision\": decision}\n        )\n        \n        # Learn from the decision\n        experience = {\n            \"situation\": situation,\n            \"goals\": goals,\n            \"options\": options,\n            \"decision\": decision\n        }\n        learning = self.learning_module.learn_from_experience(experience)\n        \n        return {\n            \"decision\": decision,\n            \"learning\": learning,\n            \"relevant_memories\": relevant_memories\n        }\n    \n    def save_state(self, filepath: str) -> None:\n        \"\"\"Save the current state of the AGI system to a file.\"\"\"\n        state = {\n            \"memories\": self.memory.memories,\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        with open(filepath, 'w') as f:\n            json.dump(state, f, indent=2)\n        \n        logger.info(f\"AGI system state saved to {filepath}\")\n    \n    def load_state(self, filepath: str) -> None:\n        \"\"\"Load the state of the AGI system from a file.\"\"\"\n        if not os.path.exists(filepath):\n            logger.warning(f\"State file {filepath} does not exist\")\n            return\n        \n        with open(filepath, 'r') as f:\n            state = json.load(f)\n        \n        self.memory.memories = state[\"memories\"]\n        logger.info(f\"AGI system state loaded from {filepath}\")\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Initialize the AGI system\n    agi = AGISystem()\n    \n    # Process some user input\n    user_input = \"What is the meaning of life?\"\n    result = agi.process_input(user_input)\n    print(f\"Response: {result['response']['content']}\")\n    \n    # Make a decision\n    situation = \"I need to choose between two job offers\"\n    goals = [\"career growth\", \"work-life balance\", \"financial stability\"]\n    options = [\"Job A: Higher salary but longer hours\", \"Job B: Lower salary but better work-life balance\"]\n    decision_result = agi.make_decision(situation, goals, options)\n    print(f\"Decision: {decision_result['decision']['decision']}\")\n    \n    # Save the system state\n    agi.save_state(\"agi_state.json\")\n"
        },
        {
            "filename": "agi_interface.py",
            "content": "\"\"\"AGI Interface - A user interface for interacting with the AGI system.\n\nThis module provides a command-line interface for interacting with the AGI system.\nIt includes functionality for processing input, displaying responses, and managing the system.\n\"\"\"\n\nimport argparse\nimport json\nimport logging\nfrom typing import Dict, Any\nfrom agi_system import AGISystem\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass AGIInterface:\n    \"\"\"Command-line interface for the AGI system.\"\"\"\n    \n    def __init__(self, state_file: str = \"agi_state.json\"):\n        \"\"\"Initialize the AGI interface.\"\"\"\n        self.agi = AGISystem()\n        self.state_file = state_file\n        \n        # Load previous state if it exists\n        self.agi.load_state(self.state_file)\n    \n    def run_interactive(self):\n        \"\"\"Run the AGI system in interactive mode.\"\"\"\n        print(\"AGI System - Interactive Mode\")\n        print(\"Type 'exit' to quit, 'save' to save state, 'reset' to reset memories\")\n        \n        while True:\n            try:\n                user_input = input(\"\\nYou: \")\n                \n                if user_input.lower() == 'exit':\n                    self.agi.save_state(self.state_file)\n                    print(\"Goodbye!\")\n                    break\n                \n                elif user_input.lower() == 'save':\n                    self.agi.save_state(self.state_file)\n                    print(\"State saved.\")\n                    continue\n                \n                elif user_input.lower() == 'reset':\n                    self.agi.memory.memories = []\n                    print(\"Memories reset.\")\n                    continue\n                \n                # Process the input\n                result = self.agi.process_input(user_input)\n                \n                # Display the response\n                print(f\"\\nAGI: {result['response']['content']}\")\n                \n                # Display confidence score if available\n                if 'confidence' in result['response']:\n                    print(f\"\\nConfidence: {result['response']['confidence']:.2f}\")\n                \n                # Display reasoning if needed\n                if result['response'].get('clarification_needed', False):\n                    print(\"\\n[Note: AGI is seeking clarification]\")\n                    \n            except KeyboardInterrupt:\n                self.agi.save_state(self.state_file)\n                print(\"\\nState saved. Goodbye!\")\n                break\n            except Exception as e:\n                logger.error(f\"Error in interactive mode: {str(e)}\")\n                print(\"An error occurred. Please try again.\")\n    \n    def run_single_query(self, query: str) -> Dict[str, Any]:\n        \"\"\"Process a single query and return the result.\"\"\"\n        return self.agi.process_input(query)\n    \n    def make_decision(self, situation: str, goals: str, options: str) -> Dict[str, Any]:\n        \"\"\"Make a decision based on the provided situation, goals, and options.\"\"\"\n        # Parse goals and options from string\n        goals_list = [g.strip() for g in goals.split(\",\")]\n        options_list = [o.strip() for o in options.split(\",\")]\n        \n        return self.agi.make_decision(situation, goals_list, options_list)\n\n\ndef main():\n    \"\"\"Main function to run the AGI interface.\"\"\"\n    parser = argparse.ArgumentParser(description=\"AGI System Interface\")\n    parser.add_argument(\"--query\", type=str