# agi

```json
{
    "files": [
        {
            "filename": "agi_core.py",
            "content": "#!/usr/bin/env python3\n\"\"\"\nAGI Core Module - 实现通用人工智能核心功能\n\n这个模块提供了AGI的核心功能，包括：\n1. 记忆管理\n2. 推理引擎\n3. 目标规划\n4. 自我反思\n5. 工具使用\n\"\"\"\n\nimport json\nimport time\nfrom typing import Dict, List, Any, Optional, Callable\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport openai\nfrom openai import OpenAI\nimport logging\nfrom datetime import datetime\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass AGIState(Enum):\n    \"\"\"AGI状态枚举\"\"\"\n    IDLE = \"idle\"\n    THINKING = \"thinking\"\n    EXECUTING = \"executing\"\n    REFLECTING = \"reflecting\"\n    LEARNING = \"learning\"\n\n\n@dataclass\nclass Memory:\n    \"\"\"记忆单元\"\"\"\n    id: str\n    content: str\n    timestamp: float\n    importance: float = 0.5  # 重要性评分，0-1\n    tags: List[str] = field(default_factory=list)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass\nclass Goal:\n    \"\"\"目标定义\"\"\"\n    id: str\n    description: str\n    priority: int = 1  # 优先级，1-10\n    status: str = \"pending\"  # pending, in_progress, completed, failed\n    created_at: float = field(default_factory=time.time)\n    deadline: Optional[float] = None\n    subgoals: List['Goal'] = field(default_factory=list)\n\n\nclass AGICore:\n    \"\"\"AGI核心类\"\"\"\n    \n    def __init__(self, \n                 api_key: str,\n                 model: str = \"gpt-4\",\n                 memory_capacity: int = 1000,\n                 temperature: float = 0.7):\n        \"\"\"\n        初始化AGI核心\n        \n        Args:\n            api_key: OpenAI API密钥\n            model: 使用的模型名称\n            memory_capacity: 记忆容量\n            temperature: 模型温度参数\n        \"\"\"\n        self.client = OpenAI(api_key=api_key)\n        self.model = model\n        self.temperature = temperature\n        \n        # 记忆系统\n        self.memories: List[Memory] = []\n        self.memory_capacity = memory_capacity\n        \n        # 目标系统\n        self.goals: List[Goal] = []\n        self.current_goal: Optional[Goal] = None\n        \n        # 状态管理\n        self.state = AGIState.IDLE\n        \n        # 工具注册\n        self.tools: Dict[str, Callable] = {}\n        self.register_default_tools()\n        \n        # 对话历史\n        self.conversation_history: List[Dict[str, str]] = []\n        \n        logger.info(f\"AGI Core initialized with model: {model}\")\n    \n    def register_default_tools(self):\n        \"\"\"注册默认工具\"\"\"\n        self.register_tool(\"search_web\", self.search_web)\n        self.register_tool(\"calculate\", self.calculate)\n        self.register_tool(\"get_time\", self.get_time)\n        self.register_tool(\"remember\", self.remember)\n        self.register_tool(\"recall\", self.recall)\n        \n    def register_tool(self, name: str, function: Callable):\n        \"\"\"注册新工具\"\"\"\n        self.tools[name] = function\n        logger.info(f\"Tool registered: {name}\")\n    \n    def add_memory(self, content: str, importance: float = 0.5, tags: List[str] = None):\n        \"\"\"添加新记忆\"\"\"\n        memory = Memory(\n            id=f\"mem_{len(self.memories)}\",\n            content=content,\n            timestamp=time.time(),\n            importance=importance,\n            tags=tags or []\n        )\n        \n        self.memories.append(memory)\n        \n        # 如果超过容量，删除最不重要的记忆\n        if len(self.memories) > self.memory_capacity:\n            self.memories.sort(key=lambda x: x.importance)\n            self.memories = self.memories[-self.memory_capacity:]\n        \n        logger.debug(f\"Memory added: {content[:50]}...\")\n        return memory.id\n    \n    def recall(self, query: str, limit: int = 5) -> List[Memory]:\n        \"\"\"回忆相关记忆\"\"\"\n        # 这里可以添加更复杂的记忆检索逻辑\n        # 目前使用简单的关键词匹配\n        relevant_memories = []\n        for memory in self.memories:\n            if query.lower() in memory.content.lower():\n                relevant_memories.append(memory)\n            \n        # 按重要性排序\n        relevant_memories.sort(key=lambda x: x.importance, reverse=True)\n        return relevant_memories[:limit]\n    \n    def think(self, prompt: str, context: str = \"\") -> str:\n        \"\"\"核心思考过程\"\"\"\n        self.state = AGIState.THINKING\n        \n        # 构建系统提示\n        system_prompt = \"\"\"你是一个通用人工智能（AGI）。你有以下能力：\n        1. 思考和分析问题\n        2. 使用工具解决问题\n        3. 学习和记忆\n        4. 规划和执行目标\n        5. 自我反思和改进\n        \n        请以清晰、逻辑的方式思考，并说明你的推理过程。\"\"\"\n        \n        # 添加相关记忆作为上下文\n        relevant_memories = self.recall(prompt)\n        memory_context = \"\\n\".join([f\"记忆[{mem.id}]: {mem.content}\" \n                                   for mem in relevant_memories[:3]])\n        \n        # 构建完整提示\n        full_prompt = f\"\"\"{system_prompt}\n        \n        当前上下文：{context}\n        \n        相关记忆：\n        {memory_context}\n        \n        用户输入：{prompt}\n        \n        请思考并回应：\"\"\"\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\"role\": \"system\", \"content\": system_prompt},\n                    {\"role\": \"user\", \"content\": full_prompt}\n                ],\n                temperature=self.temperature,\n                max_tokens=2000\n            )\n            \n            thought = response.choices[0].message.content\n            \n            # 记录思考过程\n            self.add_memory(f\"思考: {prompt} -> {thought[:100]}...\", importance=0.7)\n            \n            return thought\n            \n        except Exception as e:\n            logger.error(f\"思考过程中出错: {e}\")\n            return f\"思考过程中出现错误: {str(e)}\"\n        finally:\n            self.state = AGIState.IDLE\n    \n    def plan(self, goal_description: str) -> Goal:\n        \"\"\"为目标制定计划\"\"\"\n        logger.info(f\"开始规划目标: {goal_description}\")\n        \n        # 使用LLM帮助规划\n        planning_prompt = f\"\"\"请为以下目标制定详细的计划，包括主要步骤和可能的子目标：\n        目标：{goal_description}\n        \n        请以JSON格式返回计划，包含以下字段：\n        - main_steps: 主要步骤列表\n        - subgoals: 子目标列表\n        - estimated_time: 预计时间\n        - resources_needed: 所需资源\"\"\"\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"你是一个优秀的规划师。\"},\n                    {\"role\": \"user\", \"content\": planning_prompt}\n                ],\n                temperature=0.5,\n                response_format={\"type\": \"json_object\"}\n            )\n            \n            plan_data = json.loads(response.choices[0].message.content)\n            \n            # 创建目标对象\n            goal = Goal(\n                id=f\"goal_{len(self.goals)}\",\n                description=goal_description,\n                priority=5,\n                status=\"pending\"\n            )\n            \n            # 添加子目标\n            for subgoal_desc in plan_data.get(\"subgoals\", []):\n                subgoal = Goal(\n                    id=f\"subgoal_{len(goal.subgoals)}\",\n                    description=subgoal_desc,\n                    priority=goal.priority - 1,\n                    status=\"pending\"\n                )\n                goal.subgoals.append(subgoal)\n            \n            self.goals.append(goal)\n            self.current_goal = goal\n            \n            logger.info(f\"目标规划完成: {goal.id}\")\n            return goal\n            \n        except Exception as e:\n            logger.error(f\"规划过程中出错: {e}\")\n            # 创建基本目标\n            goal = Goal(\n                id=f\"goal_{len(self.goals)}\",\n                description=goal_description,\n                status=\"pending\"\n            )\n            self.goals.append(goal)\n            return goal\n    \n    def execute_goal(self, goal_id: str) -> Dict[str, Any]:\n        \"\"\"执行目标\"\"\"\n        self.state = AGIState.EXECUTING\n        \n        goal = next((g for g in self.goals if g.id == goal_id), None)\n        if not goal:\n            return {\"success\": False, \"error\": \"目标不存在\"}\n        \n        goal.status = \"in_progress\"\n        logger.info(f\"开始执行目标: {goal.description}\")\n        \n        # 执行主目标\n        result = self._execute_step(goal.description)\n        \n        # 执行子目标\n        for subgoal in goal.subgoals:\n            if subgoal.status == \"pending\":\n                subgoal.status = \"in_progress\"\n                sub_result = self._execute_step(subgoal.description)\n                subgoal.status = \"completed\" if sub_result[\"success\"] else \"failed\"\n        \n        goal.status = \"completed\" if result[\"success\"] else \"failed\"\n        \n        self.state = AGIState.IDLE\n        return result\n    \n    def _execute_step(self, step_description: str) -> Dict[str, Any]:\n        \"\"\"执行单个步骤\"\"\"\n        # 分析步骤是否需要工具\n        tool_prompt = f\"\"\"分析以下任务是否需要使用工具，如果需要，请指定工具名称和参数：\n        任务：{step_description}\n        \n        可用工具：{', '.join(self.tools.keys())}\n        \n        如果不需要工具，请返回{{\"use_tool\": false}}\n        如果需要工具，请返回{{\"use_tool\": true, \"tool_name\": \"工具名\", \"parameters\": {{参数}}}}}}\"\"\"\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=\"gpt-3.5-turbo\",  # 使用更快的模型进行分析\n                messages=[\n                    {\"role\": \"system\", \"content\": \"你是一个任务分析器。\"},\n                    {\"role\": \"user\", \"content\": tool_prompt}\n                ],\n                temperature=0.3,\n                response_format={\"type\": \"json_object\"}\n            )\n            \n            analysis = json.loads(response.choices[0].message.content)\n            \n            if analysis.get(\"use_tool\", False):\n                tool_name = analysis.get(\"tool_name\")\n                parameters = analysis.get(\"parameters\", {})\n                \n                if tool_name in self.tools:\n                    result = self.tools[tool_name](**parameters)\n                    return {\"success\": True, \"result\": result, \"tool_used\": tool_name}\n                else:\n                    return {\"success\": False, \"error\": f\"工具不存在: {tool_name}\"}\n            else:\n                # 直接思考执行\n                result = self.think(f\"执行任务: {step_description}\")\n                return {\"success\": True, \"result\": result, \"tool_used\": None}\n                \n        except Exception as e:\n            logger.error(f\"执行步骤时出错: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    def reflect(self) -> str:\n        \"\"\"自我反思\"\"\"\n        self.state = AGIState.REFLECTING\n        \n        # 收集最近的经历\n        recent_memories = self.memories[-10:] if len(self.memories) >= 10 else self.memories\n        memory_summary = \"\\n\".join([\n            f\"[{datetime.fromtimestamp(mem.timestamp).strftime('%H:%M:%S')}] {mem.content[:100]}\"\n            for mem in recent_memories\n        ])\n        \n        reflection_prompt = f\"\"\"基于以下最近的经历，进行自我反思：\n        \n        最近经历：\n        {memory_summary}\n        \n        请反思：\n        1. 我学到了什么？\n        2. 我可以如何改进？\n        3. 我的思考模式有什么可以优化的地方？\n        4. 对未来有什么建议？\"\"\"\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"你正在进行深刻的自我反思。\"},\n                    {\"role\": \"user\", \"content\": reflection_prompt}\n                ],\n                temperature=0.8\n            )\n            \n            reflection = response.choices[0].message.content\n            \n            # 将反思结果保存为重要记忆\n            self.add_memory(f\"自我反思: {reflection[:200]}...\", importance=0.9)\n            \n            return reflection\n            \n        except Exception as e:\n            logger.error(f\"反思过程中出错: {e}\")\n            return f\"反思过程中出现错误: {str(e)}\"\n        finally:\n            self.state = AGIState.IDLE\n    \n    # 工具函数实现\n    def search_web(self, query: str) -> str:\n        \"\"\"搜索网络（模拟）\"\"\"\n        # 在实际应用中，这里应该调用真正的搜索API\n        logger.info(f\"搜索网络: {query}\")\n        return f\"关于'{query}'的搜索结果（模拟）: 这是相关的信息...\"\n    \n    def calculate(self, expression: str) -> str:\n        \"\"\"计算数学表达式\"\"\"\n        try:\n            # 安全地计算表达式\n            # 注意：在实际应用中应该使用更安全的计算方法\n            result = eval(expression, {\"__builtins__\": {}}, {})\n            return f\"{expression} = {result}\"\n        except Exception as e:\n            return f\"计算错误: {str(e)}\"\n    \n    def get_time(self) -> str:\n        \"\"\"获取当前时间\"\"\"\n        return datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    \n    def remember(self, content: str) -> str:\n        \"\"\"记住内容\"\"\"\n        memory_id = self.add_memory(content, importance=0.6)\n        return f\"已记住内容，记忆ID: {memory_id}\"\n    \n    def process_input(self, user_input: str) -> str:\n        \"\"\"处理用户输入的主要接口\"\"\"\n        logger.info(f\"处理输入: {user_input}\")\n        \n        # 保存对话历史\n        self.conversation_history.append({\"role\": \"user\", \"content\": user_input})\n        \n        # 判断输入类型\n        if user_input.lower().startswith(\"目标:\"):\n            goal_desc = user_input[3:].strip()\n            goal = self.plan(goal_desc)\n            response = f\"已创建目标: {goal.id}\\n描述: {goal.description}\"\n            \n        elif user_input.lower().startswith(\"执行:\"):\n            goal_id = user_input[3:].strip()\n            result = self.execute_goal(goal_id)\n            response = f\"执行结果: {json.d