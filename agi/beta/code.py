# agi

{
    "files": [
        {
            "filename": "agi/core/agent.py",
            "content": "# agi/core/agent.py\n# 高级工程师实现：AGI核心代理模块\n# 遵循模块化、可扩展、反思-规划-执行（RPE）架构\n\nimport os\nimport json\nimport logging\nimport asyncio\nfrom typing import Dict, List, Optional, Any, Tuple, Callable\nfrom enum import Enum\nfrom datetime import datetime\n\nimport openai\nfrom pydantic import BaseModel, Field\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 初始化OpenAI客户端\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\nif not openai.api_key:\n    raise ValueError(\"OPENAI_API_KEY environment variable not set.\")\n\n\nclass Thought(BaseModel):\n    \"\"\"思维单元：记录推理过程中的中间状态\"\"\"\n    id: str = Field(default_factory=lambda: f\"t_{int(datetime.now().timestamp() * 1000)}\")\n    content: str\n    reasoning_type: str  # e.g., 'planning', 'reflection', 'execution', 'meta-cognition'\n    confidence: float = Field(ge=0.0, le=1.0, default=0.5)\n    timestamp: datetime = Field(default_factory=datetime.now)\n    parent_id: Optional[str] = None\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n\nclass MemoryEntry(BaseModel):\n    \"\"\"记忆条目：长期/短期记忆存储结构\"\"\"\n    id: str\n    content: str\n    type: str  # 'short_term', 'long_term', 'skill', 'fact', 'experience'\n    importance: float = Field(ge=0.0, le=1.0, default=0.5)\n    last_accessed: datetime = Field(default_factory=datetime.now)\n    tags: List[str] = Field(default_factory=list)\n\n\nclass TaskStatus(str, Enum):\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    REJECTED = \"rejected\"\n\n\nclass Task(BaseModel):\n    \"\"\"任务定义：支持嵌套子任务与目标分解\"\"\"\n    id: str\n    description: str\n    goal: str\n    subtasks: List['Task'] = Field(default_factory=list)\n    status: TaskStatus = TaskStatus.PENDING\n    created_at: datetime = Field(default_factory=datetime.now)\n    completed_at: Optional[datetime] = None\n    result: Optional[str] = None\n    error: Optional[str] = None\n    context: Dict[str, Any] = Field(default_factory=dict)\n\n# 为递归引用修复\nTask.update_forward_refs()\n\n\nclass AGIAgent:\n    \"\"\"\n    真正意义上的AGI核心代理：\n    - 支持多层级目标分解与自我反思\n    - 动态记忆管理（短期+长期）\n    - 工具调用与环境交互能力\n    - 元认知监控（监控自身认知状态）\n    - 异步并发执行\n    \"\"\"\n\n    def __init__(self, name: str = \"AGI-Agent\", max_thoughts: int = 50):\n        self.name = name\n        self.thoughts: List[Thought] = []\n        self.memory: List[MemoryEntry] = []\n        self.task_stack: List[Task] = []\n        self.max_thoughts = max_thoughts\n        self.tools: Dict[str, Callable] = {}\n        self.tool_descriptions: Dict[str, str] = {}\n        self._tool_registry_initialized = False\n        logger.info(f\"AGI Agent '{self.name}' initialized.\")\n\n    def register_tool(self, name: str, func: Callable, description: str):\n        \"\"\"注册外部工具（如搜索、计算、API调用等）\"\"\"\n        self.tools[name] = func\n        self.tool_descriptions[name] = description\n        logger.debug(f\"Tool '{name}' registered.\")\n\n    async def _call_llm(\n        self,\n        messages: List[Dict[str, str]],\n        model: str = \"gpt-4-turbo\",\n        temperature: float = 0.7,\n        max_tokens: int = 1024,\n        functions: Optional[List[Dict]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"统一LLM调用接口，支持函数调用\"\"\"\n        try:\n            response = await openai.ChatCompletion.acreate(\n                model=model,\n                messages=messages,\n                temperature=temperature,\n                max_tokens=max_tokens,\n                functions=functions,\n                function_call=\"auto\" if functions else None\n            )\n            return response.choices[0].message.dict()\n        except Exception as e:\n            logger.error(f\"LLM call failed: {e}\")\n            raise\n\n    async def _reflect(self, context: str) -> Thought:\n        \"\"\"自我反思模块：评估当前状态、错误、改进点\"\"\"\n        prompt = f\"\"\"\nYou are a self-reflective AGI agent. Analyze the following context critically and honestly:\n\nContext:\n{context}\n\nProvide:\n1. What went well?\n2. What went wrong or could be improved?\n3. How should future actions adapt?\n4. Confidence level (0.0–1.0) in this reflection.\n\nRespond ONLY in JSON format with keys: 'well', 'improvement', 'adaptation', 'confidence'.\n\"\"\"\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a reflective AGI agent. Be concise, honest, and constructive.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        raw_resp = await self._call_llm(messages, model=\"gpt-4-turbo\", temperature=0.3)\n        try:\n            resp_json = json.loads(raw_resp.get(\"content\", \"{}\"))\n            content = f\"Reflection:\\n- Well: {resp_json.get('well', '')}\\n- Improvement: {resp_json.get('improvement', '')}\\n- Adaptation: {resp_json.get('adaptation', '')}\"\n            confidence = float(resp_json.get(\"confidence\", 0.5))\n        except Exception:\n            content = f\"Reflection failed; fallback: {raw_resp.get('content', 'N/A')}\"\n            confidence = 0.3\n\n        thought = Thought(\n            content=content,\n            reasoning_type=\"reflection\",\n            confidence=confidence,\n            parent_id=self.thoughts[-1].id if self.thoughts else None\n        )\n        self._record_thought(thought)\n        return thought\n\n    def _record_thought(self, thought: Thought):\n        \"\"\"记录思维，自动清理旧思维以控制内存\"\"\"\n        self.thoughts.append(thought)\n        if len(self.thoughts) > self.max_thoughts:\n            self.thoughts.pop(0)  # FIFO 清理\n\n    async def _plan(self, goal: str, context: str = \"\") -> List[Task]:\n        \"\"\"目标分解与规划：生成可执行的子任务树\"\"\"\n        prompt = f\"\"\"\nYou are an AGI planner. Given a goal and context, decompose it into a hierarchical list of concrete, executable subtasks.\nEach subtask must have:\n- A clear description\n- A measurable completion condition\n- Dependencies (if any)\n\nGoal: {goal}\nContext: {context or '[None]'}\n\nOutput ONLY valid JSON array of tasks with keys: 'description', 'goal', 'dependencies' (array of task IDs).\nDo NOT include code, explanations, or markdown.\n\"\"\"\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a precise, hierarchical planner. Output only JSON.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        raw_resp = await self._call_llm(messages, model=\"gpt-4-turbo\", temperature=0.2)\n        try: \n            tasks_data = json.loads(raw_resp.get(\"content\", \"[]\"))\n            tasks = []\n            for i, td in enumerate(tasks_data):\n                tid = f\"task_{int(datetime.now().timestamp())}_{i}\"\n                tasks.append(Task(\n                    id=tid,\n                    description=td.get(\"description\", \"Unknown\"),\n                    goal=td.get(\"goal\", \"\"),\n                    context={\"original_input\": goal, \"planner_context\": context}\n                ))\n            return tasks\n        except Exception as e:\n            logger.warning(f\"Planning failed: {e}. Falling back to single task.\")\n            return [Task(id=f\"task_{int(datetime.now().timestamp())}\", description=goal, goal=goal)]\n\n    async def _execute_task(self, task: Task) -> Task:\n        \"\"\"执行单个任务：支持工具调用与自主推理\"\"\"\n        # Step 1: 构建执行上下文\n        memory_context = \"\\n\".join([\n            f\"[Memory {me.id}]: {me.content} (type: {me.type})\"\n            for me in self.memory[-5:]  # 最近5条记忆\n        ])\n\n        tool_descs = \"\\n\".join([f\"- {name}: {desc}\" for name, desc in self.tool_descriptions.items()])\n        tools_list = list(self.tools.keys())\n\n        prompt = f\"\"\"\nYou are an AGI executor. Your task is:\nGoal: {task.goal}\nDescription: {task.description}\n\nAvailable tools: {tools_list}\nTool descriptions:\n{tool_descs}\n\nMemory context (recent):\n{memory_context or '[No recent memory]'}\n\nInstructions:\n1. Decide whether to use a tool or reason directly.\n2. If using a tool, output ONLY a JSON with 'tool_call': {{\"name\": \"...\", \"arguments\": {{...}}}}\n3. If reasoning, output ONLY a JSON with 'reasoning': \"...\"\n4. Never output extra text.\n\nBe efficient and precise.\n\"\"\"\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an autonomous executor. Output ONLY valid JSON.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n\n        # 准备函数定义（用于function calling）\n        functions = [\n            {\n                \"name\": name,\n                \"description\": desc,\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"arguments\": {\n                            \"type\": \"object\",\n                            \"description\": \"Arguments for the tool\"\n                        }\n                    },\n                    \"required\": [\"arguments\"]\n                }\n            }\n            for name, desc in self.tool_descriptions.items()\n        ]\n\n        try:\n            resp = await self._call_llm(messages, functions=functions)\n            content = resp.get(\"content\")\n            func_call = resp.get(\"function_call\")\n\n            if func_call:\n                func_name = func_call[\"name\"]\n                try:\n                    args = json.loads(func_call[\"arguments\"])\n                    if func_name in self.tools:\n                        result = await self.tools[func_name](**args)\n                        task.result = str(result)\n                        task.status = TaskStatus.COMPLETED\n                        # 存入短期记忆\n                        self._remember(f\"Tool '{func_name}' executed with result: {result}\", \"short_term\", tags=[\"execution\", func_name])\n                    else:\n                        task.error = f\"Tool '{func_name}' not found.\"\n                        task.status = TaskStatus.FAILED\n                except Exception as e:\n                    task.error = f\"Tool execution error: {e}\"\n                    task.status = TaskStatus.FAILED\n            elif content:\n                try:\n                    data = json.loads(content)\n                    if \"reasoning\" in data:\n                        task.result = data[\"reasoning\"]\n                        task.status = TaskStatus.COMPLETED\n                        self._remember(data[\"reasoning\"], \"short_term\", tags=[\"reasoning\"])\n                    else:\n                        task.result = content\n                        task.status = TaskStatus.COMPLETED\n                except json.JSONDecodeError:\n                    task.result = content\n                    task.status = TaskStatus.COMPLETED\n            else:\n                task.error = \"No valid response from LLM.\"\n                task.status = TaskStatus.FAILED\n\n        except Exception as e:\n            task.error = f\"Execution exception: {e}\"\n            task.status = TaskStatus.FAILED\n\n        task.completed_at = datetime.now()\n        return task\n\n    def _remember(self, content: str, mem_type: str = \"short_term\", importance: float = 0.6, tags: List[str] = None):\n        \"\"\"存入记忆库\"\"\"\n        entry = MemoryEntry(\n            id=f\"mem_{int(datetime.now().timestamp() * 1000)}\",\n            content=content,\n            type=mem_type,\n            importance=importance,\n            tags=tags or []\n       )\n        self.memory.append(entry)\n        # 可选：定期压缩长期记忆（此处简化）\n        if len(self.memory) > 200:\n            self.memory = self.memory[-150:]  # 保留最近150条\n\n    async def run(self, goal: str, context: str = \"\") -> Task:\n        \"\"\"\n        主入口：启动AGI循环 —— 规划 → 执行 → 反思 → 迭代\n        支持递归任务分解与异常恢复\n        \"\"\"\n        logger.info(f\"Starting AGI run for goal: '{goal}'\")\n\n        root_task = Task(id=f\"root_{int(datetime.now().timestamp())}\", description=goal, goal=goal)\n        self.task_stack.append(root_task)\n\n        try:\n            # Step 1: Planning\n            thoughts = await self._plan(goal, context)\n            root_task.subtasks = thoughts\n            self._record_thought(Thought(\n                content=f\"Planned {len(thoughts)} subtasks for goal '{goal}'\",\n                reasoning_type=\"planning\",\n                confidence=0.8\n            ))\n\n            # Step 2: Execute subtasks sequentially (can be parallelized later)\n            for subtask in root_task.subtasks:\n                logger.info(f\"Executing subtask: {subtask.description}\")\n                executed = await self._execute_task(subtask)\n                if executed.status == TaskStatus.FAILED:\n                    # Step 3: Reflection on failure\n                   反思_context = f\"Task failed: {executed.description}\\nError: {executed.error}\\nLast thoughts: {[t.content[:100] for t in self.thoughts[-3:]]}\"\n                    await self._reflect(反思_context)\n                    # 尝试重试一次（简化策略）\n                    if \"retry\" not in str(executed.error).lower():\n                        logger.warning(f\"Retrying failed task: {subtask.id}\")\n                        executed = await self._execute_task(subtask)\n                # 更新根任务状态\n                if executed.status == TaskStatus.COMPLETED:\n                    root_task.status = TaskStatus.IN_PROGRESS\n\n            # Final reflection\n            final_context = f\"Goal: {goal}\\nCompleted tasks: {[t.description for t in root_task.subtasks if t.status == TaskStatus.COMPLETED]}\\nFailed: {[t.description for t in root_task.subtasks if t.status == TaskStatus.FAILED]}\"\n            await self._reflect(final_context)\n\n            root_task.status = TaskStatus.COMPLETED if all(t.status == TaskStatus.COMPLETED for t in root_task.subtasks) else TaskStatus.FAILED\n            root_task.result = \"; \".join([t.result or \"N/A\" for t in root_task.subtasks if t.result])\n\n        except Exception as e:\n            root_task.error = f\"AGI run crashed: {e}\"\n            root_task.status = TaskStatus.FAILED\n            logger.exception(\"AGI run exception\")\n        finally:\n            self.task_stack.pop()\n\n        return root_task\n\n\n# 示例工具注册（可在主程序中扩展）\nasync def search_web(query: str) -> str:\n    \"\"\"模拟搜索工具 — 实际项目中应替换为真实API（如Tavily）\"\"\"\n    return f\"[Mock Search Result] Top 3 pages about '{query}' found. Summary: AI safety, AGI timelines, cognitive architectures.\"\n\n\nasync def calculate(expr: str) -> str:\n    \"\"\"安全计算工具（仅允许简单表达式）\"\"\"\n    try:\n        # 仅允许数字和基本运算符\n        if not all(c in \"0123456789+-*/(). \" for c in expr):\n            return \"Invalid expression: unsafe characters.\"\n        result = eval(expr, {\"__builtins__\": {}}, {})\n        return str(result)\n    except Exception as e:\n        return f\"Calc error: {e}\"\n"
        },
        {
            "filename": "agi/__init__.py",
