# agi

```json
{
    "files": [
        {
            "filename": "agi_core.py",
            "content": "\"\"\"AGI核心模块，实现通用人工智能的核心功能\"\"\"\n\nimport os\nimport json\nimport logging\nfrom typing import Dict, List, Any, Optional\nfrom dataclasses import dataclass\nfrom openai import OpenAI\nimport numpy as np\nfrom memory_system import MemorySystem\nfrom planning_system import PlanningSystem\nfrom learning_system import LearningSystem\nfrom perception_system import PerceptionSystem\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass AGIConfig:\n    \"\"\"AGI配置类\"\"\"\n    openai_api_key: str = os.getenv(\"OPENAI_API_KEY\", \"\")\n    model_name: str = \"gpt-4-turbo\"\n    max_tokens: int = 4096\n    temperature: float = 0.7\n    memory_capacity: int = 10000\n    planning_horizon: int = 10\n    learning_rate: float = 0.01\n    \n    def __post_init__(self):\n        if not self.openai_api_key:\n            raise ValueError(\"OpenAI API key is required\")\n\n\nclass AGICore:\n    \"\"\"AGI核心系统\"\"\"\n    \n    def __init__(self, config: AGIConfig):\n        \"\"\"初始化AGI核心系统\"\"\"\n        self.config = config\n        self.client = OpenAI(api_key=config.openai_api_key)\n        \n        # 初始化各个子系统\n        self.memory_system = MemorySystem(capacity=config.memory_capacity)\n        self.planning_system = PlanningSystem(horizon=config.planning_horizon)\n        self.learning_system = LearningSystem(rate=config.learning_rate)\n        self.perception_system = PerceptionSystem()\n        \n        # AGI状态\n        self.current_goal: Optional[str] = None\n        self.current_plan: List[str] = []\n        self.knowledge_base: Dict[str, Any] = {}\n        self.active: bool = False\n        \n        logger.info(\"AGI Core initialized successfully\")\n    \n    def perceive(self, input_data: Any) -> Dict[str, Any]:\n        \"\"\"感知输入数据并提取有用信息\"\"\"\n        logger.info(\"Perceiving input data...\")\n        processed_data = self.perception_system.process(input_data)\n        \n        # 存储到记忆系统\n        self.memory_system.store(\"perception\", processed_data)\n        \n        return processed_data\n    \n    def reason(self, context: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"基于上下文进行推理\"\"\"\n        logger.info(\"Reasoning based on context...\")\n        \n        # 从记忆中检索相关信息\n        relevant_memories = self.memory_system.retrieve(\"reasoning\", context)\n        \n        # 使用OpenAI API进行复杂推理\n        reasoning_prompt = self._build_reasoning_prompt(context, relevant_memories)\n        response = self._call_openai(reasoning_prompt)\n        \n        # 解析推理结果\n        reasoning_result = self._parse_reasoning_response(response)\n        \n        # 存储推理过程和结果\n        self.memory_system.store(\"reasoning\", {\n            \"context\": context,\n            \"result\": reasoning_result\n        })\n        \n        return reasoning_result\n    \n    def plan(self, goal: str) -> List[str]:\n        \"\"\"制定实现目标的计划\"\"\"\n        logger.info(f\"Planning for goal: {goal}\")\n        \n        # 使用规划系统生成计划\n        plan = self.planning_system.generate_plan(goal, self.knowledge_base)\n        \n        # 存储计划\n        self.current_plan = plan\n        self.current_goal = goal\n        \n        # 存储到记忆系统\n        self.memory_system.store(\"planning\", {\n            \"goal\": goal,\n            \"plan\": plan\n        })\n        \n        return plan\n    \n    def act(self, action: str) -> Dict[str, Any]:\n        \"\"\"执行行动并获取反馈\"\"\"\n        logger.info(f\"Executing action: {action}\")\n        \n        # 使用OpenAI API生成行动执行策略\n        action_prompt = self._build_action_prompt(action)\n        response = self._call_openai(action_prompt)\n        \n        # 解析行动策略\n        action_strategy = self._parse_action_response(response)\n        \n        # 在实际应用中，这里会调用相应的行动执行系统\n        # 目前我们模拟行动执行\n        result = {\"action\": action, \"status\": \"simulated\", \"output\": None}\n        \n        # 存储行动和结果\n        self.memory_system.store(\"action\", {\n            \"action\": action,\n            \"strategy\": action_strategy,\n            \"result\": result\n        })\n        \n        return result\n    \n    def learn(self, feedback: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"从反馈中学习并更新知识库\"\"\"\n        logger.info(\"Learning from feedback...\")\n        \n        # 使用学习系统处理反馈\n        learning_result = self.learning_system.process_feedback(feedback)\n        \n        # 更新知识库\n        self.knowledge_base.update(learning_result.get(\"new_knowledge\", {}))\n        \n        # 存储学习结果\n        self.memory_system.store(\"learning\", learning_result)\n        \n        return learning_result\n    \n    def process_input(self, input_data: Any) -> Dict[str, Any]:\n        \"\"\"处理输入的完整流程\"\"\"\n        if not self.active:\n            raise RuntimeError(\"AGI is not active\")\n            \n        logger.info(\"Processing input...\")\n        \n        # 1. 感知\n        perception = self.perceive(input_data)\n        \n        # 2. 推理\n        reasoning = self.reason(perception)\n        \n        # 3. 计划（如果没有当前目标）\n        if not self.current_goal:\n            goal = reasoning.get(\"suggested_goal\")\n            if goal:\n                self.plan(goal)\n        \n        # 4. 执行\n        if self.current_plan:\n            action = self.current_plan.pop(0)\n            action_result = self.act(action)\n            \n            # 5. 学习\n            learning = self.learn(action_result)\n            \n            return {\n                \"perception\": perception,\n                \"reasoning\": reasoning,\n                \"action\": action_result,\n                \"learning\": learning\n            }\n        \n        return {\n            \"perception\": perception,\n            \"reasoning\": reasoning,\n            \"action\": None,\n            \"learning\": None\n        }\n    \n    def start(self):\n        \"\"\"启动AGI系统\"\"\"\n        logger.info(\"Starting AGI system...\")\n        self.active = True\n        \n    def stop(self):\n        \"\"\"停止AGI系统\"\"\"\n        logger.info(\"Stopping AGI system...\")\n        self.active = False\n    \n    def save_state(self, filepath: str):\n        \"\"\"保存AGI状态到文件\"\"\"\n        state = {\n            \"current_goal\": self.current_goal,\n            \"current_plan\": self.current_plan,\n            \"knowledge_base\": self.knowledge_base,\n            \"memory\": self.memory_system.export_memory()\n        }\n        \n        with open(filepath, 'w') as f:\n            json.dump(state, f, indent=2)\n        \n        logger.info(f\"AGI state saved to {filepath}\")\n    \n    def load_state(self, filepath: str):\n        \"\"\"从文件加载AGI状态\"\"\"\n        with open(filepath, 'r') as f:\n            state = json.load(f)\n            \n        self.current_goal = state.get(\"current_goal\")\n        self.current_plan = state.get(\"current_plan\", [])\n        self.knowledge_base = state.get(\"knowledge_base\", {})\n        self.memory_system.import_memory(state.get(\"memory\", {}))\n        \n        logger.info(f\"AGI state loaded from {filepath}\")\n    \n    def _call_openai(self, prompt: str) -> str:\n        \"\"\"调用OpenAI API\"\"\"\n        try:\n            response = self.client.chat.completions.create(\n                model=self.config.model_name,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"You are an AGI system helping to solve complex problems and achieve goals.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ],\n                max_tokens=self.config.max_tokens,\n                temperature=self.config.temperature\n            )\n            return response.choices[0].message.content\n        except Exception as e:\n            logger.error(f\"Error calling OpenAI API: {e}\")\n            raise\n    \n    def _build_reasoning_prompt(self, context: Dict[str, Any], memories: List[Dict[str, Any]]) -> str:\n        \"\"\"构建推理提示\"\"\"\n        prompt = \"\"\"\n        Based on the following context and memories, provide a comprehensive analysis:\n        \n        Context:\n        {json.dumps(context, indent=2)}\n        \n        Relevant Memories:\n        {json.dumps(memories, indent=2)}\n        \n        Please provide:\n        1. Key insights from the context\n        2. Connections to past experiences\n        3. Potential opportunities or threats\n        4. Suggestions for next steps or goals\n        \"\"\"\n        return prompt\n    \n    def _build_action_prompt(self, action: str) -> str:\n        \"\"\"构建行动提示\"\"\"\n        prompt = f\"\"\"\n        I need to execute the following action: {action}\n        \n        Current goal: {self.current_goal}\n        Current knowledge base: {json.dumps(self.knowledge_base, indent=2)}\n        \n        Please provide:\n        1. Step-by-step execution strategy\n        2. Potential risks and how to mitigate them\n        3. Expected outcomes and success criteria\n        4. How to measure the success of this action\n        \"\"\"\n        return prompt\n    \n    def _parse_reasoning_response(self, response: str) -> Dict[str, Any]:\n        \"\"\"解析推理响应\"\"\"\n        try:\n            # 尝试解析JSON响应\n            return json.loads(response)\n        except json.JSONDecodeError:\n            # 如果不是JSON，则返回文本\n            return {\"raw_response\": response}\n    \n    def _parse_action_response(self, response: str) -> Dict[str, Any]:\n        \"\"\"解析行动响应\"\"\"\n        try:\n            # 尝试解析JSON响应\n            return json.loads(response)\n        except json.JSONDecodeError:\n            # 如果不是JSON，则返回文本\n            return {\"raw_response\": response}"
        },
        {
            "filename": "memory_system.py",
            "content": "\"\"\"记忆系统，用于存储、检索和管理AGI的记忆\"\"\"\n\nimport numpy as np\nfrom typing import Dict, List, Any, Optional\nfrom collections import deque\nimport json\nimport pickle\nimport os\nfrom datetime import datetime\n\n\nclass MemorySystem:\n    \"\"\"记忆系统，实现AGI的记忆功能\"\"\"\n    \n    def __init__(self, capacity: int = 10000):\n        \"\"\"初始化记忆系统\n        \n        Args:\n            capacity: 记忆的最大容量\n        \"\"\"\n        self.capacity = capacity\n        self.memories = deque(maxlen=capacity)  # 使用双端队列实现记忆存储\n        self.memory_index = {}  # 记忆索引，用于快速检索\n        self.memory_types = set()  # 记忆类型集合\n        \n    def store(self, memory_type: str, content: Any, metadata: Optional[Dict[str, Any]] = None):\n        \"\"\"存储记忆\n        \n        Args:\n            memory_type: 记忆类型（如\"perception\", \"reasoning\", \"planning\", \"action\", \"learning\"）\n            content: 记忆内容\n            metadata: 记忆的元数据\n        \"\"\"\n        timestamp = datetime.now().isoformat()\n        memory_id = len(self.memories)\n        \n        # 创建记忆对象\n        memory = {\n            \"id\": memory_id,\n            \"type\": memory_type,\n            \"content\": content,\n            \"timestamp\": timestamp,\n            \"metadata\": metadata or {}\n        }\n        \n        # 添加到记忆存储\n        self.memories.append(memory)\n        \n        # 更新索引\n        if memory_type not in self.memory_index:\n            self.memory_index[memory_type] = []\n        self.memory_index[memory_type].append(memory_id)\n        \n        # 添加到记忆类型集合\n        self.memory_types.add(memory_type)\n        \n    def retrieve(self, memory_type: str, query: Any, k: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"检索记忆\n        \n        Args:\n            memory_type: 记忆类型\n            query: 查询内容\n            k: 返回的记忆数量\n            \n        Returns:\n            匹配的记忆列表\n        \"\"\"\n        if memory_type not in self.memory_index:\n            return []\n            \n        # 获取该类型的所有记忆ID\n        memory_ids = self.memory_index[memory_type]\n        \n        # 获取对应的记忆\n        memories = [self.memories[mid] for mid in memory_ids]\n        \n        # 使用简单的相似度计算（在实际应用中可以使用更复杂的算法）\n        scored_memories = []\n        for memory in memories:\n            similarity = self._calculate_similarity(query, memory[\"content\"])\n            scored_memories.append((memory, similarity))\n            \n        # 按相似度排序\n        scored_memories.sort(key=lambda x: x[1], reverse=True)\n        \n        # 返回前k个记忆\n        return [memory for memory, _ in scored_memories[:k]]\n    \n    def get_recent_memories(self, memory_type: Optional[str] = None, k: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"获取最近的记忆\n        \n        Args:\n            memory_type: 记忆类型，如果为None则返回所有类型的记忆\n            k: 返回的记忆数量\n            \n        Returns:\n            最近的记忆列表\n        \"\"\"\n        if memory_type is None:\n            # 返回所有类型的最近记忆\n            return [memory for memory in list(self.memories)[-k:]]\n        else:\n            # 返回特定类型的最近记忆\n            memory_ids = self.memory_index.get(memory_type, [])\n            memories = [self.memories[mid] for mid in memory_ids]\n            return memories[-k:]\n    \n    def get_memory_by_id(self, memory_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"根据ID获取记忆\n        \n        Args:\n            memory_id: 记忆ID\n            \n        Returns:\n            记忆对象，如果不存在则返回None\n        \"\"\"\n        if 0 <= memory_id < len(self.memories):\n            return self.memories[memory_id]\n        return None\n    \n    def export_memory(self) -> Dict[str, Any]:\n        \"\"\"导出记忆数据\n        \n        Returns:\n            包含所有记忆数据的字典\n        \"\"\"\n        return {\n            \"capacity\": self.capacity,\n            \"memories\": list(self.memories),\n            \"memory_index\": self.memory_index,\n            \"memory_types\": list(self.memory_types)\n        }\n    \n    def import_memory(self, memory_data: Dict[str, Any]):\n        \"\"\"导入记忆数据\n        \n        Args:\n            memory_data: 包含记忆数据的字典\n        \"\"\"\n        self.capacity = memory_data.get(\"capacity\", self.capacity)\n        self.memories = deque(memory_data.get(\"memories\", []), maxlen=self.capacity)\n        self.memory_index = memory_data.get(\"memory_index\", {})\n        self.memory_types = set(memory_data.get(\"memory_types\", []))\n    \n    def save_to_file(self, filepath: str):\n        \"\"\"将记忆保存到文件\n        \n        Args:\n            filepath: 文件路径\n        \"\"\"\n        with open(filepath, 'wb') as f:\n            pickle.dump(self.export_memory(), f)\n            \n    def load_from_file(self, filepath: str):\n        \"\"\"从文件加载记忆\n        \n        Args:\n            filepath: 文件路径\n        \"\"\"\n        if os.path.exists(filepath):\n            with open(filepath, 'rb') as f:\n                memory_data = pickle.load(f)\n                self.import_memory(memory_data)\n        else:\n            raise FileNotFoundError(f\"Memory file {filepath} not found\")\n    \n    def _calculate_similarity(self, query: Any, memory_content: Any) -> float:\n        \"\"\"计算查询与记忆内容的相似度\n        \n        这是一个简化的相似度计算方法，实际应用中可以使用更复杂的算法\n        \"\"\"\n        # 如果都是字典，比较键值对\n        if isinstance(query, dict) and isinstance(memory_content,