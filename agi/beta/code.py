# agi

 ```json
{
  "files": [
    {
      "filename": "config/settings.py",
      "content": "\"\"\"\nAGI Project Configuration\n全局配置管理，支持环境变量覆盖\n\"\"\"\nimport os\nfrom typing import Optional\nfrom pydantic_settings import BaseSettings\nfrom pydantic import Field\n\n\nclass Settings(BaseSettings):\n    \"\"\"应用配置类\"\"\"\n    \n    # OpenAI Configuration\n    openai_api_key: str = Field(default=\"\", description=\"OpenAI API密钥\")\n    openai_base_url: Optional[str] = Field(default=None, description=\"OpenAI API基础URL\")\n    model_name: str = Field(default=\"gpt-4-1106-preview\", description=\"主模型名称\")\n    embedding_model: str = Field(default=\"text-embedding-3-small\", description=\"嵌入模型\")\n    \n    # AGI Behavior Configuration\n    max_iterations: int = Field(default=50, description=\"单次任务最大迭代次数\")\n    reflection_interval: int = Field(default=5, description=\"反思间隔步数\")\n    temperature: float = Field(default=0.7, description=\"模型温度\")\n    \n    # Memory Configuration\n    memory_retrieval_top_k: int = Field(default=5, description=\"记忆检索top-k\")\n    vector_db_path: str = Field(default=\"./data/vector_db\", description=\"向量数据库路径\")\n    \n    # Tool Configuration\n    enable_code_execution: bool = Field(default=True, description=\"是否启用代码执行\")\n    sandbox_timeout: int = Field(default=30, description=\"沙箱执行超时(秒)\")\n    \n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n\n# 全局配置实例\nsettings = Settings()\n"
    },
    {
      "filename": "core/memory.py",
      "content": "\"\"\"\nAGI Memory System\n实现多层级记忆架构：\n1. 工作记忆（Working Memory）- 当前上下文\n2. 短期记忆（Short-term）- 近期对话历史\n3. 长期记忆（Long-term）- 向量数据库持久化存储\n4. 情节记忆（Episodic）- 具体事件记录\n\"\"\"\nimport json\nimport hashlib\nfrom datetime import datetime\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom dataclasses import dataclass, asdict\nfrom abc import ABC, abstractmethod\nimport numpy as np\nfrom openai import AsyncOpenAI\nimport chromadb\nfrom chromadb.config import Settings as ChromaSettings\n\nfrom config.settings import settings\n\n\n@dataclass\nclass MemoryEntry:\n    \"\"\"记忆条目数据结构\"\"\"\n    content: str\n    memory_type: str  # 'observation', 'thought', 'action', 'reflection'\n    timestamp: datetime\n    importance: float  # 0-1, 用于记忆巩固\n    metadata: Dict[str, Any]\n    embedding: Optional[List[float]] = None\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"content\": self.content,\n            \"memory_type\": self.memory_type,\n            \"timestamp\": self.timestamp.isoformat(),\n            \"importance\": self.importance,\n            \"metadata\": self.metadata\n        }\n\n\nclass BaseMemoryStore(ABC):\n    \"\"\"记忆存储基类\"\"\"\n    \n    @abstractmethod\n    async def add(self, entry: MemoryEntry) -> str:\n        \"\"\"添加记忆，返回记忆ID\"\"\"\n        pass\n    \n    @abstractmethod\n    async def retrieve(\n        self, \n        query: str, \n        top_k: int = 5,\n        memory_type: Optional[str] = None\n    ) -> List[MemoryEntry]:\n        \"\"\"检索相关记忆\"\"\"\n        pass\n    \n    @abstractmethod\n    async def consolidate(self) -> None:\n        \"\"\"记忆巩固（压缩、总结旧记忆）\"\"\"\n        pass\n\n\nclass VectorMemoryStore(BaseMemoryStore):\n    \"\"\"基于ChromaDB的向量记忆存储\"\"\"\n    \n    def __init__(self, client: AsyncOpenAI):\n        self.client = client\n        self.chroma_client = chromadb.PersistentClient(\n            path=settings.vector_db_path,\n            settings=ChromaSettings(anonymized_telemetry=False)\n        )\n        self.collection = self.chroma_client.get_or_create_collection(\n            name=\"long_term_memory\",\n            metadata={\"hnsw:space\": \"cosine\"}\n        )\n        \n    async def _get_embedding(self, text: str) -> List[float]:\n        \"\"\"获取文本嵌入向量\"\"\"\n        response = await self.client.embeddings.create(\n            model=settings.embedding_model,\n            input=text\n        )\n        return response.data[0].embedding\n    \n    async def add(self, entry: MemoryEntry) -> str:\n        \"\"\"添加记忆到长期存储\"\"\"\n        memory_id = hashlib.md5(\n            f\"{entry.content}{entry.timestamp}\".encode()\n       