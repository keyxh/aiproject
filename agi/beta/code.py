# agi

```json
{
    "files": [
        {
            "filename": "agi_core.py",
            "content": "#!/usr/bin/env python3\n\"\"\"\nAGI核心模块 - 实现通用人工智能的核心逻辑\n\n这个模块提供了AGI系统的基础架构，包括记忆管理、任务分解、推理执行等核心功能。\n使用OpenAI API作为底层模型服务。\n\"\"\"\n\nimport json\nimport logging\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom datetime import datetime\nimport openai\nfrom dataclasses import dataclass, asdict\nfrom enum import Enum\nimport hashlib\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    \"\"\"任务状态枚举\"\"\"\n    PENDING = \"pending\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n\n\n@dataclass\nclass MemoryItem:\n    \"\"\"记忆项数据结构\"\"\"\n    id: str\n    content: str\n    timestamp: datetime\n    metadata: Dict[str, Any]\n    importance: float  # 0-1之间的重要性评分\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"转换为字典格式\"\"\"\n        data = asdict(self)\n        data['timestamp'] = self.timestamp.isoformat()\n        return data\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    id: str\n    description: str\n    status: TaskStatus\n    created_at: datetime\n    completed_at: Optional[datetime] = None\n    result: Optional[str] = None\n    subtasks: List['Task'] = None\n    metadata: Dict[str, Any] = None\n\n    def __post_init__(self):\n        if self.subtasks is None:\n            self.subtasks = []\n        if self.metadata is None:\n            self.metadata = {}\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"转换为字典格式\"\"\"\n        data = asdict(self)\n        data['status'] = self.status.value\n        data['created_at'] = self.created_at.isoformat()\n        if self.completed_at:\n            data['completed_at'] = self.completed_at.isoformat()\n        data['subtasks'] = [task.to_dict() for task in self.subtasks]\n        return data\n\n\nclass MemoryManager:\n    \"\"\"记忆管理器\"\"\"\n    \n    def __init__(self, max_memories: int = 1000):\n        \"\"\"\n        初始化记忆管理器\n        \n        Args:\n            max_memories: 最大记忆数量\n        \"\"\"\n        self.memories: List[MemoryItem] = []\n        self.max_memories = max_memories\n        \n    def add_memory(self, content: str, metadata: Dict[str, Any] = None, \n                   importance: float = 0.5) -> str:\n        \"\"\"\n        添加新的记忆\n        \n        Args:\n            content: 记忆内容\n            metadata: 元数据\n            importance: 重要性评分（0-1）\n            \n        Returns:\n            记忆ID\n        \"\"\"\n        if metadata is None:\n            metadata = {}\n            \n        # 生成唯一ID\n        memory_id = hashlib.md5(\n            f\"{content}{datetime.now().isoformat()}\".encode()\n        ).hexdigest()[:16]\n        \n        memory = MemoryItem(\n            id=memory_id,\n            content=content,\n            timestamp=datetime.now(),\n            metadata=metadata,\n            importance=importance\n        )\n        \n        self.memories.append(memory)\n        \n        # 如果超过最大记忆数，删除最不重要的记忆\n        if len(self.memories) > self.max_memories:\n            self.memories.sort(key=lambda x: x.importance)\n            self.memories = self.memories[-self.max_memories:]\n        \n        logger.info(f\"Added memory: {memory_id}\")\n        return memory_id\n    \n    def search_memories(self, query: str, limit: int = 10) -> List[MemoryItem]:\n        \"\"\"\n        搜索相关记忆\n        \n        Args:\n            query: 搜索查询\n            limit: 返回结果数量限制\n            \n        Returns:\n            相关记忆列表\n        \"\"\"\n        # 简单实现：基于关键词匹配\n        # 在实际应用中，可以使用向量搜索或更复杂的语义匹配\n        query_lower = query.lower()\n        \n        relevant_memories = []\n        for memory in self.memories:\n            if query_lower in memory.content.lower():\n                relevant_memories.append(memory)\n        \n        # 按重要性排序\n        relevant_memories.sort(key=lambda x: x.importance, reverse=True)\n        \n        return relevant_memories[:limit]\n    \n    def get_context(self, query: str, max_tokens: int = 2000) -> str:\n        \"\"\"\n        获取相关上下文\n        \n        Args:\n            query: 查询内容\n            max_tokens: 最大token数\n            \n        Returns:\n            上下文字符串\n        \"\"\"\n        relevant_memories = self.search_memories(query)\n        \n        context_parts = []\n        total_tokens = 0\n        \n        for memory in relevant_memories:\n            memory_text = f\"[{memory.timestamp.strftime('%Y-%m-%d %H:%M')}] {memory.content}\"\n            memory_tokens = len(memory_text.split())  # 简单估算\n            \n            if total_tokens + memory_tokens > max_tokens:\n                break\n                \n            context_parts.append(memory_text)\n            total_tokens += memory_tokens\n        \n        return \"\\n\".join(context_parts)\n\n\nclass AGICore:\n    \"\"\"AGI核心类\"\"\"\n    \n    def __init__(self, api_key: str, model: str = \"gpt-4\"):\n        \"\"\"\n        初始化AGI核心\n        \n        Args:\n            api_key: OpenAI API密钥\n            model: 使用的模型名称\n        \"\"\"\n        self.client = openai.OpenAI(api_key=api_key)\n        self.model = model\n        self.memory_manager = MemoryManager()\n        self.tasks: Dict[str, Task] = {}\n        self.conversation_history: List[Dict[str, str]] = []\n        \n        # 系统提示词\n        self.system_prompt = \"\"\"你是一个通用人工智能（AGI）系统。你的目标是理解用户的需求，\n分解复杂任务，利用记忆和推理能力解决问题，并持续学习。\n\n你的能力包括：\n1. 任务分解：将复杂问题分解为可执行的子任务\n2. 记忆管理：存储和检索相关信息\n3. 推理能力：基于现有信息进行逻辑推理\n4. 自我反思：评估自己的表现并改进\n\n请以专业、有帮助的方式与用户交互。\"\"\"\n        \n        logger.info(f\"AGI Core initialized with model: {model}\")\n    \n    def _generate_task_id(self) -> str:\n        \"\"\"生成任务ID\"\"\"\n        return hashlib.md5(datetime.now().isoformat().encode()).hexdigest()[:16]\n    \n    def create_task(self, description: str) -> str:\n        \"\"\"\n        创建新任务\n        \n        Args:\n            description: 任务描述\n            \n        Returns:\n            任务ID\n        \"\"\"\n        task_id = self._generate_task_id()\n        \n        task = Task(\n            id=task_id,\n            description=description,\n            status=TaskStatus.PENDING,\n            created_at=datetime.now()\n        )\n        \n        self.tasks[task_id] = task\n        logger.info(f\"Created task: {task_id} - {description}\")\n        \n        return task_id\n    \n    def decompose_task(self, task_id: str) -> List[str]:\n        \"\"\"\n        分解任务为子任务\n        \n        Args:\n            task_id: 任务ID\n            \n        Returns:\n            子任务ID列表\n        \"\"\"\n        if task_id not in self.tasks:\n            raise ValueError(f\"Task {task_id} not found\")\n            \n        task = self.tasks[task_id]\n        \n        # 使用LLM分解任务\n        prompt = f\"\"\"请将以下任务分解为具体的子任务：\n\n任务：{task.description}\n\n请以JSON数组格式返回子任务描述，每个子任务应该：\n1. 具体可执行\n2. 有明确的完成标准\n3. 按逻辑顺序排列\n\n格式示例：[\"子任务1描述\", \"子任务2描述\", ...]\"\"\"\n        \n        response = self.client.chat.completions.create(\n            model=self.model,\n            messages=[\n                {\"role\": \"system\", \"content\": \"你是一个任务分解专家。\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ],\n            temperature=0.3\n        )\n        \n        try:\n            subtask_descriptions = json.loads(response.choices[0].message.content)\n        except json.JSONDecodeError:\n            # 如果JSON解析失败，尝试提取数组\n            content = response.choices[0].message.content\n            # 简单提取引号内的内容\n            import re\n            subtask_descriptions = re.findall(r'\"([^\"]+)\"', content)\n        \n        subtask_ids = []\n        for desc in subtask_descriptions:\n            subtask_id = self._generate_task_id()\n            subtask = Task(\n                id=subtask_id,\n                description=desc,\n                status=TaskStatus.PENDING,\n                created_at=datetime.now(),\n                metadata={\"parent_task_id\": task_id}\n            )\n            \n            self.tasks[subtask_id] = subtask\n            task.subtasks.append(subtask)\n            subtask_ids.append(subtask_id)\n            \n        task.status = TaskStatus.EXECUTING\n        \n        logger.info(f\"Decomposed task {task_id} into {len(subtask_ids)} subtasks\")\n        return subtask_ids\n    \n    def execute_subtask(self, subtask_id: str) -> str:\n        \"\"\"\n        执行子任务\n        \n        Args:\n            subtask_id: 子任务ID\n            \n        Returns:\n            执行结果\n        \"\"\"\n        if subtask_id not in self.tasks:\n            raise ValueError(f\"Subtask {subtask_id} not found\")\n            \n        subtask = self.tasks[subtask_id]\n        \n        # 获取相关上下文\n        context = self.memory_manager.get_context(subtask.description)\n        \n        # 构建执行提示\n        prompt = f\"\"\"请执行以下任务：\n\n任务描述：{subtask.description}\n\n相关上下文：\n{context}\n\n请提供详细的执行结果。如果任务需要特定操作（如计算、分析、创作等），\n请完成这些操作并返回结果。\"\"\"\n        \n        response = self.client.chat.completions.create(\n            model=self.model,\n            messages=[\n                {\"role\": \"system\", \"content\": \"你是一个任务执行专家。\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ],\n            temperature=0.7\n        )\n        \n        result = response.choices[0].message.content\n        \n        # 更新任务状态\n        subtask.status = TaskStatus.COMPLETED\n        subtask.completed_at = datetime.now()\n        subtask.result = result\n        \n        # 将结果存入记忆\n        self.memory_manager.add_memory(\n            content=f\"执行任务: {subtask.description}\\n结果: {result[:200]}...\",\n            metadata={\n                \"task_id\": subtask_id,\n                \"type\": \"task_execution\"\n            },\n            importance=0.7\n        )\n        \n        logger.info(f\"Executed subtask: {subtask_id}\")\n        return result\n    \n    def process_query(self, query: str) -> str:\n        \"\"\"\n        处理用户查询\n        \n        Args:\n            query: 用户查询\n            \n        Returns:\n            响应内容\n        \"\"\"\n        # 添加到对话历史\n        self.conversation_history.append({\"role\": \"user\", \"content\": query})\n        \n        # 获取相关记忆\n        context = self.memory_manager.get_context(query)\n        \n        # 构建消息列表\n        messages = [\n            {\"role\": \"system\", \"content\": self.system_prompt}\n        ]\n        \n        # 添加上下文\n        if context:\n            messages.append({\n                \"role\": \"system\", \n                \"content\": f\"相关记忆：\\n{context}\"\n            })\n        \n        # 添加对话历史（最近5轮）\n        recent_history = self.conversation_history[-10:]  # 最近5轮对话\n        for msg in recent_history:\n            messages.append(msg)\n        \n        # 调用API\n        response = self.client.chat.completions.create(\n            model=self.model,\n            messages=messages,\n            temperature=0.8,\n            max_tokens=2000\n        )\n        \n        answer = response.choices[0].message.content\n        \n        # 添加到对话历史\n        self.conversation_history.append({\"role\": \"assistant\", \"content\": answer})\n        \n        # 将查询和响应存入记忆\n        self.memory_manager.add_memory(\n            content=f\"用户查询: {query}\\n响应: {answer[:200]}...\",\n            metadata={\n                \"type\": \"conversation\",\n                \"timestamp\": datetime.now().isoformat()\n            },\n            importance=0.6\n        )\n        \n        # 如果查询看起来像是一个任务，自动创建任务\n        if self._is_task_query(query):\n            task_id = self.create_task(query)\n            answer += f\"\\n\\n我已将此识别为一个任务，并创建了任务ID: {task_id}\"\n            \n        return answer\n    \n    def _is_task_query(self, query: str) -> bool:\n        \"\"\"判断查询是否是一个任务\"\"\"\n        task_keywords = [\n            \"请帮我\", \"我需要\", \"请完成\", \"请执行\", \"请分析\",\n            \"请计算\", \"请编写\", \"请设计\", \"请解决\", \"请处理\"\n        ]\n        \n        query_lower = query.lower()\n        return any(keyword in query_lower for keyword in task_keywords)\n    \n    def get_task_status(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        获取任务状态\n        \n        Args:\n            task_id: 任务ID\n            \n        Returns:\n            任务状态信息\n        \"\"\"\n        if task_id not in self.tasks:\n            raise ValueError(f\"Task {task_id} not found\")\n            \n        task = self.tasks[task_id]\n        return task.to_dict()\n    \n    def reflect_on_performance(self) -> str:\n        \"\"\"\n        自我反思：评估系统表现\n        \n        Returns:\n            反思结果\n        \"\"\"\n        # 获取最近的对话和任务\n        recent_conversations = self.conversation_history[-20:]\n        recent_tasks = list(self.tasks.values())[-10:]\n        \n        conversation_summary = \"\\n\".join([\n            f\"{msg['role']}: {msg['content'][:100]}...\" \n            for msg in recent_conversations\n        ])\n        \n        task_summary = \"\\n\".join([\n            f\"任务 {task.id}: {task.description[:50]}... - 状态: {task.status.value}\"\n            for task in recent_tasks\n        ])\n        \n        prompt = f\"\"\"请基于以下信息对我的表现进行反思：\n\n最近对话：\n{conversation_summary}\n\n最近任务：\n{task_summary}\n\n请分析：\n1. 我在哪些方面做得好？\n2. 我有哪些可以改进的地方？\n3. 基于当前交互，我应该学习什么新知识或技能？\n4. 对我的系统配置