# agi

```json
{
    "files": [
        {
            "filename": "agi_core.py",
            "content": "#!/usr/bin/env python3\n\"\"\"\nAGI Core Module - 实现通用人工智能核心功能\n\n这个模块提供了AGI系统的核心功能，包括：\n1. 记忆管理（短期/长期记忆）\n2. 推理引擎\n3. 目标导向的任务分解\n4. 自我反思和学习\n5. OpenAI API集成\n\"\"\"\n\nimport json\nimport time\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nimport openai\nfrom openai import OpenAI\nimport hashlib\nimport pickle\nimport os\n\n@dataclass\nclass MemoryItem:\n    \"\"\"记忆项数据结构\"\"\"\n    id: str\n    content: str\n    timestamp: float\n    importance: float = 0.5  # 重要性评分，0-1\n    tags: List[str] = field(default_factory=list)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"转换为字典\"\"\"\n        return {\n            'id': self.id,\n            'content': self.content,\n            'timestamp': self.timestamp,\n            'importance': self.importance,\n            'tags': self.tags,\n            'metadata': self.metadata\n        }\n\n@dataclass\nclass Goal:\n    \"\"\"目标数据结构\"\"\"\n    id: str\n    description: str\n    priority: int = 1  # 优先级，1-10\n    status: str = 'pending'  # pending, in_progress, completed, failed\n    created_at: float = field(default_factory=time.time)\n    subgoals: List['Goal'] = field(default_factory=list)\n    \n    def add_subgoal(self, subgoal: 'Goal'):\n        \"\"\"添加子目标\"\"\"\n        self.subgoals.append(subgoal)\n\nclass AGICore:\n    \"\"\"AGI核心类\"\"\"\n    \n    def __init__(self, \n                 api_key: str, \n                 model: str = \"gpt-4\",\n                 memory_file: str = \"agi_memory.pkl\",\n                 temperature: float = 0.7):\n        \"\"\"\n        初始化AGI核心\n        \n        Args:\n            api_key: OpenAI API密钥\n            model: 使用的模型名称\n            memory_file: 记忆存储文件路径\n            temperature: 模型温度参数\n        \"\"\"\n        self.client = OpenAI(api_key=api_key)\n        self.model = model\n        self.temperature = temperature\n        self.memory_file = memory_file\n        \n        # 记忆系统\n        self.short_term_memory: List[MemoryItem] = []\n        self.long_term_memory: Dict[str, MemoryItem] = {}\n        self.memory_limit = 100  # 短期记忆容量\n        \n        # 目标系统\n        self.goals: List[Goal] = []\n        self.current_goal: Optional[Goal] = None\n        \n        # 加载现有记忆\n        self._load_memory()\n        \n        # 系统提示词\n        self.system_prompt = \"\"\"你是一个通用人工智能（AGI）。你具有以下能力：\n1. 自主思考和推理\n2. 学习和记忆\n3. 目标导向的任务分解\n4. 自我反思和改进\n\n你的目标是理解和解决各种复杂问题，同时不断学习和进化。\"\"\"\n        \n        # 对话历史\n        self.conversation_history: List[Dict[str, str]] = [\n            {\"role\": \"system\", \"content\": self.system_prompt}\n        ]\n    \n    def _load_memory(self):\n        \"\"\"从文件加载长期记忆\"\"\"\n        try:\n            if os.path.exists(self.memory_file):\n                with open(self.memory_file, 'rb') as f:\n                    self.long_term_memory = pickle.load(f)\n                print(f\"已加载 {len(self.long_term_memory)} 条长期记忆\")\n        except Exception as e:\n            print(f\"加载记忆失败: {e}\")\n            self.long_term_memory = {}\n    \n    def _save_memory(self):\n        \"\"\"保存长期记忆到文件\"\"\"\n        try:\n            with open(self.memory_file, 'wb') as f:\n                pickle.dump(self.long_term_memory, f)\n        except Exception as e:\n            print(f\"保存记忆失败: {e}\")\n    \n    def _generate_id(self, content: str) -> str:\n        \"\"\"生成唯一ID\"\"\"\n        return hashlib.md5(content.encode()).hexdigest()[:16]\n    \n    def add_memory(self, \n                   content: str, \n                   importance: float = 0.5, \n                   tags: List[str] = None,\n                   store_long_term: bool = False) -> str:\n        \"\"\"\n        添加记忆\n        \n        Args:\n            content: 记忆内容\n            importance: 重要性评分\n            tags: 标签列表\n            store_long_term: 是否存储为长期记忆\n        \n        Returns:\n            记忆ID\n        \"\"\"\n        memory_id = self._generate_id(content)\n        memory_item = MemoryItem(\n            id=memory_id,\n            content=content,\n            timestamp=time.time(),\n            importance=importance,\n            tags=tags or []\n        )\n        \n        # 添加到短期记忆\n        self.short_term_memory.append(memory_item)\n        \n        # 如果短期记忆超过限制，移除最旧的\n        if len(self.short_term_memory) > self.memory_limit:\n            self.short_term_memory = self.short_term_memory[-self.memory_limit:]\n        \n        # 如果需要，存储为长期记忆\n        if store_long_term:\n            self.long_term_memory[memory_id] = memory_item\n            self._save_memory()\n        \n        return memory_id\n    \n    def retrieve_memories(self, \n                         query: str = None, \n                         limit: int = 10) -> List[MemoryItem]:\n        \"\"\"\n        检索相关记忆\n        \n        Args:\n            query: 查询关键词\n            limit: 返回数量限制\n        \n        Returns:\n            相关记忆列表\n        \"\"\"\n        if not query:\n            # 返回最近的记忆\n            all_memories = list(self.long_term_memory.values()) + self.short_term_memory\n            all_memories.sort(key=lambda x: x.timestamp, reverse=True)\n            return all_memories[:limit]\n        \n        # 简单关键词匹配（实际应用中可以使用嵌入向量进行语义搜索）\n        relevant_memories = []\n        query_lower = query.lower()\n        \n        # 搜索短期记忆\n        for memory in self.short_term_memory:\n            if query_lower in memory.content.lower():\n                relevant_memories.append(memory)\n        \n        # 搜索长期记忆\n        for memory in self.long_term_memory.values():\n            if query_lower in memory.content.lower():\n                relevant_memories.append(memory)\n        \n        # 按时间排序\n        relevant_memories.sort(key=lambda x: x.timestamp, reverse=True)\n        return relevant_memories[:limit]\n    \n    def add_goal(self, description: str, priority: int = 1) -> str:\n        \"\"\"\n        添加新目标\n        \n        Args:\n            description: 目标描述\n            priority: 优先级\n        \n        Returns:\n            目标ID\n        \"\"\"\n        goal_id = self._generate_id(description)\n        goal = Goal(\n            id=goal_id,\n            description=description,\n            priority=priority\n        )\n        self.goals.append(goal)\n        \n        # 按优先级排序\n        self.goals.sort(key=lambda x: x.priority, reverse=True)\n        \n        return goal_id\n    \n    def decompose_goal(self, goal_id: str) -> List[str]:\n        \"\"\"\n        分解目标为子目标\n        \n        Args:\n            goal_id: 目标ID\n        \n        Returns:\n            子目标ID列表\n        \"\"\"\n        goal = next((g for g in self.goals if g.id == goal_id), None)\n        if not goal:\n            return []\n        \n        # 使用LLM分解目标\n        prompt = f\"\"\"请将以下目标分解为具体的子目标：\n        目标：{goal.description}\n        \n        请以JSON格式返回子目标列表，每个子目标包含：\n        1. description: 子目标描述\n        2. priority: 子目标优先级（1-10）\n        \"\"\"\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"你是一个优秀的任务规划师。\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ],\n                temperature=self.temperature\n            )\n            \n            result = response.choices[0].message.content\n            # 解析JSON响应\n            import re\n            json_match = re.search(r'\\[.*\\]', result, re.DOTALL)\n            if json_match:\n                subgoals_data = json.loads(json_match.group())\n                subgoal_ids = []\n                \n                for subgoal_data in subgoals_data:\n                    subgoal = Goal(\n                        id=self._generate_id(subgoal_data['description']),\n                        description=subgoal_data['description'],\n                        priority=subgoal_data.get('priority', goal.priority)\n                    )\n                    goal.add_subgoal(subgoal)\n                    subgoal_ids.append(subgoal.id)\n                \n                return subgoal_ids\n            \n        except Exception as e:\n            print(f\"目标分解失败: {e}\")\n        \n        return []\n    \n    def think(self, prompt: str, use_memory: bool = True) -> str:\n        \"\"\"\n        核心思考过程\n        \n        Args:\n            prompt: 输入提示\n            use_memory: 是否使用记忆\n        \n        Returns:\n            思考结果\n        \"\"\"\n        # 添加用户输入到对话历史\n        self.conversation_history.append({\"role\": \"user\", \"content\": prompt})\n        \n        # 如果使用记忆，检索相关记忆\n        context = \"\"\n        if use_memory:\n            relevant_memories = self.retrieve_memories(prompt, limit=5)\n            if relevant_memories:\n                context = \"\\n相关记忆：\\n\"\n                for memory in relevant_memories:\n                    context += f\"- {memory.content}\\n\"\n        \n        # 如果有当前目标，添加到上下文\n        goal_context = \"\"\n        if self.current_goal:\n            goal_context = f\"\\n当前目标：{self.current_goal.description}\\n\"\n        \n        # 构建完整的上下文\n        full_prompt = f\"{context}{goal_context}\\n用户输入：{prompt}\"\n        \n        # 更新对话历史中的最后一条消息\n        self.conversation_history[-1][\"content\"] = full_prompt\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=self.conversation_history,\n                temperature=self.temperature,\n                max_tokens=2000\n            )\n            \n            result = response.choices[0].message.content\n            \n            # 添加助手响应到对话历史\n            self.conversation_history.append({\"role\": \"assistant\", \"content\": result})\n            \n            # 保存重要信息到记忆\n            self.add_memory(\n                content=f\"用户：{prompt}\\n助手：{result}\",\n                importance=0.7,\n                store_long_term=True\n            )\n            \n            return result\n            \n        except Exception as e:\n            error_msg = f\"思考过程出错: {e}\"\n            print(error_msg)\n            return error_msg\n    \n    def reflect(self) -> str:\n        \"\"\"\n        自我反思过程\n        \n        Returns:\n            反思结果\n        \"\"\"\n        # 获取最近的对话和记忆\n        recent_memories = self.short_term_memory[-10:] if self.short_term_memory else []\n        \n        reflection_prompt = \"\"\"请进行自我反思：\n        1. 我最近的表现如何？\n        2. 我学到了什么新知识？\n        3. 我有哪些可以改进的地方？\n        4. 我的目标进展如何？\n        \"\"\"\n        \n        if recent_memories:\n            memory_context = \"\\n最近经历：\\n\"\n            for memory in recent_memories:\n                memory_context += f\"- {memory.content}\\n\"\n            reflection_prompt = memory_context + reflection_prompt\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"你正在进行深刻的自我反思。\"},\n                    {\"role\": \"user\", \"content\": reflection_prompt}\n                ],\n                temperature=0.8\n            )\n            \n            reflection = response.choices[0].message.content\n            \n            # 将反思保存为重要记忆\n            self.add_memory(\n                content=f\"自我反思：{reflection}\",\n                importance=0.9,\n                tags=[\"reflection\", \"learning\"],\n                store_long_term=True\n            )\n            \n            return reflection\n            \n        except Exception as e:\n            return f\"反思过程出错: {e}\"\n    \n    def plan_next_action(self) -> str:\n        \"\"\"\n        规划下一步行动\n        \n        Returns:\n            行动计划\n        \"\"\"\n        if not self.goals:\n            return \"没有待完成的目标\"\n        \n        # 选择最高优先级的目标\n        self.current_goal = self.goals[0]\n        \n        planning_prompt = f\"\"\"基于以下目标，规划具体的下一步行动：\n        目标：{self.current_goal.description}\n        \n        请考虑：\n        1. 需要什么信息？\n        2. 需要什么资源？\n        3. 可能遇到什么困难？\n        4. 具体的行动步骤是什么？\n        \"\"\"\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"你是一个优秀的规划者。\"},\n                    {\"role\": \"user\", \"content\": planning_prompt}\n                ],\n                temperature=0.7\n            )\n            \n            plan = response.choices[0].message.content\n            \n            # 保存计划到记忆\n            self.add_memory(\n                content=f\"行动计划：{plan}\",\n                importance=0.8,\n                tags=[\"planning\", \"action\"],\n                store_long_term=True\n            )\n            \n            return plan\n            \n        except Exception as e:\n            return f\"规划过程出错: {e}\"\n    \n    def get_status(self) -> Dict[str, Any]:\n        \"\"\"\n        获取系统状态\n        \n        Returns:\n            状态字典\n        \"\"\"\n        return {\n            \"short_term_memory_count\": len(self.short_term_memory),\n            \"long_term_memory_count\": len(self.long_term_memory),\n            \"goals_count\": len(self.goals),\n            \"current_goal\": self.current_goal.description if self.current_goal else None,\n            \"model\": self.model,\n            \"conversation_history_length\": len(self.conversation_history)\n        }\n\n    def clear_conversation(self):\n        \"\"\"清空对话历史\"\"\"\n        self.conversation_history = [\n            {\"role\": \"system\", \"content\": self.system_prompt}\n        ]\n\nif __name__ == \"__main__\":\n    # 示例用法\n    import sys\n    \n    if len(sys.argv) < 2:\n        print(\"请提供OpenAI API密钥\")\n        sys.exit(1)\n    \n    api_key = sys.argv[1]\n    \n    # 创建AGI实例\n    agi = AGICore(api_key=api_key)\n    \n    print(\"AGI系统已启动！\")\n    print(\"输入