# agi

```json
{
    "files": [
        {
            "filename": "agi_core.py",
            "content": "#!/usr/bin/env python3\n\"\"\"\nAGI Core Module\n实现真正意义上的通用人工智能核心系统\n使用OpenAI API作为基础模型\n\"\"\"\n\nimport os\nimport json\nimport time\nimport logging\nfrom typing import Dict, List, Any, Optional, Callable\nfrom dataclasses import dataclass, asdict\nfrom datetime import datetime\nfrom enum import Enum\nimport asyncio\n\nimport openai\nfrom openai import OpenAI\n\n# 配置日志\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass AGIState(Enum):\n    \"\"\"AGI状态枚举\"\"\"\n    IDLE = \"idle\"\n    THINKING = \"thinking\"\n    EXECUTING = \"executing\"\n    LEARNING = \"learning\"\n    REFLECTING = \"reflecting\"\n    ERROR = \"error\"\n\n\n@dataclass\nclass MemoryItem:\n    \"\"\"记忆项数据结构\"\"\"\n    id: str\n    content: str\n    timestamp: float\n    importance: float  # 0-1的重要性评分\n    context: Dict[str, Any]\n    embeddings: Optional[List[float]] = None\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    id: str\n    description: str\n    priority: int  # 1-10，越高越优先\n    status: str  # pending, in_progress, completed, failed\n    created_at: float\n    completed_at: Optional[float] = None\n    result: Optional[Any] = None\n    metadata: Optional[Dict[str, Any]] = None\n\n\nclass AGICore:\n    \"\"\"\n    AGI核心类\n    实现通用人工智能的核心功能\n    \"\"\"\n    \n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        model: str = \"gpt-4\",\n        memory_size: int = 1000,\n        temperature: float = 0.7,\n        max_tokens: int = 2000\n    ):\n        \"\"\"\n        初始化AGI核心\n        \n        Args:\n            api_key: OpenAI API密钥，如果为None则从环境变量读取\n            model: 使用的模型名称\n            memory_size: 记忆容量\n            temperature: 生成温度\n            max_tokens: 最大token数\n        \"\"\"\n        self.api_key = api_key or os.getenv(\"OPENAI_API_KEY\")\n        if not self.api_key:\n            raise ValueError(\"OpenAI API key is required\")\n        \n        self.client = OpenAI(api_key=self.api_key)\n        self.model = model\n        self.temperature = temperature\n        self.max_tokens = max_tokens\n        \n        # 状态管理\n        self.state = AGIState.IDLE\n        self.current_task = None\n        \n        # 记忆系统\n        self.memory: List[MemoryItem] = []\n        self.memory_size = memory_size\n        \n        # 任务系统\n        self.tasks: Dict[str, Task] = {}\n        self.task_queue: List[str] = []  # 任务ID队列\n        \n        # 技能系统\n        self.skills: Dict[str, Callable] = {}\n        self._register_default_skills()\n        \n        # 学习记录\n        self.learning_history: List[Dict[str, Any]] = []\n        \n        logger.info(f\"AGI Core initialized with model: {model}\")\n    \n    def _register_default_skills(self) -> None:\n        \"\"\"注册默认技能\"\"\"\n        self.register_skill(\"think\", self._skill_think)\n        self.register_skill(\"analyze\", self._skill_analyze)\n        self.register_skill(\"plan\", self._skill_plan)\n        self.register_skill(\"execute\", self._skill_execute)\n        self.register_skill(\"learn\", self._skill_learn)\n        self.register_skill(\"reflect\", self._skill_reflect)\n    \n    def register_skill(self, name: str, function: Callable) -> None:\n        \"\"\"注册新技能\"\"\"\n        self.skills[name] = function\n        logger.info(f\"Skill registered: {name}\")\n    \n    async def think(self, prompt: str, context: Optional[Dict[str, Any]] = None) -> str:\n        \"\"\"\n        核心思考功能\n        \n        Args:\n            prompt: 思考提示\n            context: 上下文信息\n            \n        Returns:\n            思考结果\n        \"\"\"\n        self.state = AGIState.THINKING\n        \n        try:\n            # 构建系统提示\n            system_prompt = self._build_system_prompt(context)\n            \n            # 调用OpenAI API\n            response = await self._call_openai(\n                system_prompt=system_prompt,\n                user_prompt=prompt\n            )\n            \n            # 记录记忆\n            self._add_memory(\n                content=f\"Thought: {prompt}\\nResponse: {response}\",\n                importance=0.7,\n                context=context or {}\n            )\n            \n            return response\n            \n        except Exception as e:\n            logger.error(f\"Thinking error: {e}\")\n            self.state = AGIState.ERROR\n            raise\n        finally:\n            self.state = AGIState.IDLE\n    \n    async def execute_task(self, task_description: str) -> Any:\n        \"\"\"\n        执行任务\n        \n        Args:\n            task_description: 任务描述\n            \n        Returns:\n            任务结果\n        \"\"\"\n        self.state = AGIState.EXECUTING\n        \n        try:\n            # 创建任务\n            task = Task(\n                id=f\"task_{int(time.time())}\",\n                description=task_description,\n                priority=5,\n                status=\"in_progress\",\n                created_at=time.time(),\n                metadata={\"description\": task_description}\n            )\n            \n            self.current_task = task\n            self.tasks[task.id] = task\n            \n            logger.info(f\"Executing task: {task_description}\")\n            \n            # 分析任务\n            analysis = await self.think(\n                f\"Analyze this task and break it down into steps: {task_description}\"\n            )\n            \n            # 制定计划\n            plan = await self.think(\n                f\"Create an execution plan for: {task_description}\\n\\nAnalysis: {analysis}\"\n            )\n            \n            # 执行计划\n            result = await self._execute_plan(plan, task_description)\n            \n            # 更新任务状态\n            task.status = \"completed\"\n            task.completed_at = time.time()\n            task.result = result\n            \n            # 学习经验\n            await self.learn_from_task(task, result)\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Task execution error: {e}\")\n            if self.current_task:\n                self.current_task.status = \"failed\"\n                self.current_task.result = str(e)\n            self.state = AGIState.ERROR\n            raise\n        finally:\n            self.state = AGIState.IDLE\n            self.current_task = None\n    \n    async def learn_from_task(self, task: Task, result: Any) -> None:\n        \"\"\"从任务中学习\"\"\"\n        self.state = AGIState.LEARNING\n        \n        try:\n            learning_prompt = f\"\"\"\n            Task: {task.description}\n            Result: {result}\n            \n            What can be learned from this task execution?\n            What worked well? What could be improved?\n            How can this knowledge be applied to future tasks?\n            \"\"\"\n            \n            learning_insights = await self.think(learning_prompt)\n            \n            # 记录学习\n            learning_record = {\n                \"task_id\": task.id,\n                \"task_description\": task.description,\n                \"result\": str(result),\n                \"insights\": learning_insights,\n                \"timestamp\": time.time()\n            }\n            \n            self.learning_history.append(learning_record)\n            \n            # 添加到记忆\n            self._add_memory(\n                content=f\"Learning from task {task.id}: {learning_insights}\",\n                importance=0.8,\n                context={\"type\": \"learning\", \"task_id\": task.id}\n            )\n            \n            logger.info(f\"Learned from task {task.id}\")\n            \n        except Exception as e:\n            logger.error(f\"Learning error: {e}\")\n        finally:\n            self.state = AGIState.IDLE\n    \n    async def reflect(self) -> str:\n        \"\"\"自我反思\"\"\"\n        self.state = AGIState.REFLECTING\n        \n        try:\n            # 获取最近的记忆和任务\n            recent_memories = self.memory[-10:] if self.memory else []\n            recent_tasks = list(self.tasks.values())[-5:]\n            \n            reflection_prompt = f\"\"\"\n            Based on recent experiences, reflect on:\n            1. What have I learned recently?\n            2. What patterns do I see in my thinking and execution?\n            3. How can I improve my performance?\n            4. What new skills or knowledge should I develop?\n            \n            Recent memories: {recent_memories}\n            Recent tasks: {recent_tasks}\n            \"\"\"\n            \n            reflection = await self.think(reflection_prompt)\n            \n            # 记录反思\n            self._add_memory(\n                content=f\"Reflection: {reflection}\",\n                importance=0.9,\n                context={\"type\": \"reflection\"}\n            )\n            \n            return reflection\n            \n        except Exception as e:\n            logger.error(f\"Reflection error: {e}\")\n            raise\n        finally:\n            self.state = AGIState.IDLE\n    \n    def _build_system_prompt(self, context: Optional[Dict[str, Any]] = None) -> str:\n        \"\"\"构建系统提示\"\"\"\n        base_prompt = \"\"\"\n        You are an AGI (Artificial General Intelligence) system. \n        Your goal is to think, learn, and solve problems like a human would.\n        \n        Core principles:\n        1. Think critically and creatively\n        2. Learn from every interaction\n        3. Adapt to new situations\n        4. Reflect on your performance\n        5. Continuously improve\n        \n        You have access to various skills and can:\n        - Analyze complex problems\n        - Break down tasks into steps\n        - Execute plans\n        - Learn from experience\n        - Reflect on your thinking process\n        \n        Always provide thoughtful, detailed responses.\n        \"\"\"\n        \n        if context:\n            context_str = json.dumps(context, indent=2)\n            base_prompt += f\"\\n\\nCurrent context:\\n{context_str}\"\n        \n        return base_prompt\n    \n    async def _call_openai(\n        self,\n        system_prompt: str,\n        user_prompt: str\n    ) -> str:\n        \"\"\"调用OpenAI API\"\"\"\n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\"role\": \"system\", \"content\": system_prompt},\n                    {\"role\": \"user\", \"content\": user_prompt}\n                ],\n                temperature=self.temperature,\n                max_tokens=self.max_tokens\n            )\n            \n            return response.choices[0].message.content\n            \n        except Exception as e:\n            logger.error(f\"OpenAI API error: {e}\")\n            raise\n    \n    def _add_memory(\n        self,\n        content: str,\n        importance: float,\n        context: Dict[str, Any]\n    ) -> None:\n        \"\"\"添加记忆\"\"\"\n        memory_item = MemoryItem(\n            id=f\"mem_{int(time.time())}_{len(self.memory)}\",\n            content=content,\n            timestamp=time.time(),\n            importance=importance,\n            context=context\n        )\n        \n        self.memory.append(memory_item)\n        \n        # 保持记忆容量\n        if len(self.memory) > self.memory_size:\n            # 按重要性排序，移除最不重要的\n            self.memory.sort(key=lambda x: x.importance)\n            self.memory = self.memory[-self.memory_size:]\n    \n    async def _execute_plan(self, plan: str, task_description: str) -> Any:\n        \"\"\"执行计划\"\"\"\n        # 这里可以扩展为更复杂的计划执行逻辑\n        # 目前使用思考来执行计划\n        execution_prompt = f\"\"\"\n        Task: {task_description}\n        Plan: {plan}\n        \n        Execute this plan step by step.\n        Provide detailed results of each step.\n        \"\"\"\n        \n        return await self.think(execution_prompt)\n    \n    # 默认技能实现\n    async def _skill_think(self, **kwargs) -> str:\n        \"\"\"思考技能\"\"\"\n        prompt = kwargs.get(\"prompt\", \"\")\n        context = kwargs.get(\"context\", {})\n        return await self.think(prompt, context)\n    \n    async def _skill_analyze(self, **kwargs) -> str:\n        \"\"\"分析技能\"\"\"\n        topic = kwargs.get(\"topic\", \"\")\n        return await self.think(f\"Analyze: {topic}\")\n    \n    async def _skill_plan(self, **kwargs) -> str:\n        \"\"\"计划技能\"\"\"\n        goal = kwargs.get(\"goal\", \"\")\n        return await self.think(f\"Create a plan to achieve: {goal}\")\n    \n    async def _skill_execute(self, **kwargs) -> Any:\n        \"\"\"执行技能\"\"\"\n        task = kwargs.get(\"task\", \"\")\n        return await self.execute_task(task)\n    \n    async def _skill_learn(self, **kwargs) -> str:\n        \"\"\"学习技能\"\"\"\n        experience = kwargs.get(\"experience\", \"\")\n        return await self.think(f\"What can be learned from: {experience}\")\n    \n    async def _skill_reflect(self, **kwargs) -> str:\n        \"\"\"反思技能\"\"\"\n        return await self.reflect()\n    \n    def get_status(self) -> Dict[str, Any]:\n        \"\"\"获取当前状态\"\"\"\n        return {\n            \"state\": self.state.value,\n            \"memory_count\": len(self.memory),\n            \"task_count\": len(self.tasks),\n            \"skills_count\": len(self.skills),\n            \"learning_records\": len(self.learning_history),\n            \"current_task\": self.current_task.id if self.current_task else None\n        }\n    \n    def save_state(self, filepath: str) -> None:\n        \"\"\"保存状态到文件\"\"\"\n        state = {\n            \"memory\": [asdict(m) for m in self.memory],\n            \"tasks\": {k: asdict(v) for k, v in self.tasks.items()},\n            \"learning_history\": self.learning_history,\n            \"config\": {\n                \"model\": self.model,\n                \"memory_size\": self.memory_size,\n                \"temperature\": self.temperature\n            }\n        }\n        \n        with open(filepath, 'w') as f:\n            json.dump(state, f, indent=2)\n        \n        logger.info(f\"State saved to {filepath}\")\n    \n    def load_state(self, filepath: str) -> None:\n        \"\"\"从文件加载状态\"\"\"\n        with open(filepath, 'r') as f:\n            state = json.load(f)\n        \n        self.memory = [MemoryItem(**m) for m in state[\"memory\"]]\n        self.tasks = {k: Task(**v) for k, v in state[\"tasks\"].items()}\n        self.learning_history = state[\"learning_history\"]\n        \n        logger.info(f\"State loaded from {filepath}\")\n\n\nasync def main():\n    \"\"\"示例使用\"\"\"\n   