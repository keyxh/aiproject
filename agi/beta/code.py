# agi

```json
{
    "files": [
        {
            "filename": "agi_core.py",
            "content": "#!/usr/bin/env python3\n\"\"\"\nAGI Core Module\n实现真正意义上的通用人工智能核心逻辑\n使用OpenAI API作为底层模型\n\"\"\"\n\nimport os\nimport json\nimport logging\nfrom typing import Dict, List, Any, Optional, Callable\nfrom datetime import datetime\nfrom dataclasses import dataclass, asdict\nfrom enum import Enum\nimport asyncio\nfrom abc import ABC, abstractmethod\n\nimport openai\nfrom openai import AsyncOpenAI\n\n# 配置日志\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass AGIState(Enum):\n    \"\"\"AGI状态枚举\"\"\"\n    INITIALIZING = \"initializing\"\n    IDLE = \"idle\"\n    THINKING = \"thinking\"\n    EXECUTING = \"executing\"\n    LEARNING = \"learning\"\n    REFLECTING = \"reflecting\"\n    ERROR = \"error\"\n\n\n@dataclass\nclass Thought:\n    \"\"\"思考过程的数据结构\"\"\"\n    id: str\n    content: str\n    timestamp: datetime\n    context: Dict[str, Any]\n    reasoning_steps: List[str]\n    confidence: float\n    metadata: Dict[str, Any]\n\n\n@dataclass\nclass Action:\n    \"\"\"行动的数据结构\"\"\"\n    id: str\n    type: str  # 'api_call', 'tool_use', 'reasoning', 'learning', 'reflection'\n    description: str\n    parameters: Dict[str, Any]\n    expected_outcome: str\n    timestamp: datetime\n\n\n@dataclass\nclass MemoryItem:\n    \"\"\"记忆项的数据结构\"\"\"\n    id: str\n    content: str\n    timestamp: datetime\n    importance: float  # 0-1的重要性评分\n    category: str  # 'fact', 'skill', 'experience', 'insight'\n    embeddings: Optional[List[float]] = None\n    metadata: Dict[str, Any] = None\n\n\nclass ToolInterface(ABC):\n    \"\"\"工具接口抽象类\"\"\"\n    \n    @abstractmethod\n    async def execute(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"执行工具\"\"\"\n        pass\n    \n    @property\n    @abstractmethod\n    def name(self) -> str:\n        \"\"\"工具名称\"\"\"\n        pass\n    \n    @property\n    @abstractmethod\n    def description(self) -> str:\n        \"\"\"工具描述\"\"\"\n        pass\n    \n    @property\n    @abstractmethod\n    def parameters_schema(self) -> Dict[str, Any]:\n        \"\"\"参数模式\"\"\"\n        pass\n\n\nclass MemorySystem:\n    \"\"\"记忆系统\"\"\"\n    \n    def __init__(self, max_items: int = 10000):\n        self.memories: Dict[str, MemoryItem] = {}\n        self.max_items = max_items\n        self.embeddings_model = \"text-embedding-3-small\"\n        \n    async def store(self, content: str, category: str = 'fact', \n                   importance: float = 0.5, metadata: Dict[str, Any] = None) -> str:\n        \"\"\"存储记忆\"\"\"\n        memory_id = f\"memory_{len(self.memories)}_{datetime.now().timestamp()}\"\n        \n        # 生成嵌入向量\n        embeddings = await self._generate_embeddings(content)\n        \n        memory_item = MemoryItem(\n            id=memory_id,\n            content=content,\n            timestamp=datetime.now(),\n            importance=importance,\n            category=category,\n            embeddings=embeddings,\n            metadata=metadata or {}\n        )\n        \n        self.memories[memory_id] = memory_item\n        \n        # 如果超过最大数量，删除最不重要的记忆\n        if len(self.memories) > self.max_items:\n            self._prune_memories()\n        \n        return memory_id\n    \n    async def retrieve(self, query: str, limit: int = 10, \n                      category: Optional[str] = None) -> List[MemoryItem]:\n        \"\"\"检索相关记忆\"\"\"\n        if not self.memories:\n            return []\n        \n        # 生成查询的嵌入向量\n        query_embeddings = await self._generate_embeddings(query)\n        \n        # 计算相似度\n        similarities = []\n        for memory in self.memories.values():\n            if category and memory.category != category:\n                continue\n                \n            if memory.embeddings:\n                similarity = self._cosine_similarity(query_embeddings, memory.embeddings)\n                weighted_score = similarity * memory.importance\n                similarities.append((weighted_score, memory))\n        \n        # 按相似度排序\n        similarities.sort(key=lambda x: x[0], reverse=True)\n        \n        return [memory for _, memory in similarities[:limit]]\n    \n    async def _generate_embeddings(self, text: str) -> List[float]:\n        \"\"\"生成文本嵌入向量\"\"\"\n        try:\n            client = AsyncOpenAI()\n            response = await client.embeddings.create(\n                model=self.embeddings_model,\n                input=text\n            )\n            return response.data[0].embedding\n        except Exception as e:\n            logger.error(f\"生成嵌入向量失败: {e}\")\n            return []\n    \n    def _cosine_similarity(self, vec1: List[float], vec2: List[float]) -> float:\n        \"\"\"计算余弦相似度\"\"\"\n        if not vec1 or not vec2 or len(vec1) != len(vec2):\n            return 0.0\n        \n        dot_product = sum(a * b for a, b in zip(vec1, vec2))\n        norm1 = sum(a * a for a in vec1) ** 0.5\n        norm2 = sum(b * b for b in vec2) ** 0.5\n        \n        if norm1 == 0 or norm2 == 0:\n            return 0.0\n        \n        return dot_product / (norm1 * norm2)\n    \n    def _prune_memories(self):\n        \"\"\"修剪记忆，删除最不重要的\"\"\"\n        # 按重要性排序\n        sorted_memories = sorted(\n            self.memories.items(), \n            key=lambda x: (x[1].importance, x[1].timestamp.timestamp())\n        )\n        \n        # 删除最不重要的10%\n        to_remove = int(len(sorted_memories) * 0.1)\n        for memory_id, _ in sorted_memories[:to_remove]:\n            del self.memories[memory_id]\n\n\nclass ReasoningEngine:\n    \"\"\"推理引擎\"\"\"\n    \n    def __init__(self, model: str = \"gpt-4-turbo-preview\"):\n        self.model = model\n        self.client = AsyncOpenAI()\n        \n    async def think(self, prompt: str, context: Dict[str, Any] = None, \n                   max_tokens: int = 2000) -> Thought:\n        \"\"\"进行深度思考\"\"\"\n        thought_id = f\"thought_{datetime.now().timestamp()}\"\n        \n        # 构建系统提示\n        system_prompt = \"\"\"你是一个通用人工智能系统。请进行深度、多步骤的推理。\n        思考过程应该包括：\n        1. 问题分析\n        2. 相关知识检索\n        3. 多角度思考\n        4. 解决方案生成\n        5. 自我验证\n        \n        请详细记录你的思考步骤。\"\"\"\n        \n        # 构建用户消息\n        user_content = f\"问题/任务: {prompt}\"\n        if context:\n            user_content += f\"\\n上下文: {json.dumps(context, ensure_ascii=False)}\"\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\"role\": \"system\", \"content\": system_prompt},\n                    {\"role\": \"user\", \"content\": user_content}\n                ],\n                max_tokens=max_tokens,\n                temperature=0.7,\n                top_p=0.9\n            )\n            \n            content = response.choices[0].message.content\n            \n            # 解析思考步骤（简单实现）\n            reasoning_steps = self._extract_reasoning_steps(content)\n            \n            return Thought(\n                id=thought_id,\n                content=content,\n                timestamp=datetime.now(),\n                context=context or {},\n                reasoning_steps=reasoning_steps,\n                confidence=0.8,  # 可以基于响应质量计算\n                metadata={\n                    \"model\": self.model,\n                    \"tokens_used\": response.usage.total_tokens\n                }\n            )\n            \n        except Exception as e:\n            logger.error(f\"思考过程失败: {e}\")\n            raise\n    \n    def _extract_reasoning_steps(self, content: str) -> List[str]:\n        \"\"\"从思考内容中提取步骤\"\"\"\n        # 简单的步骤提取逻辑\n        steps = []\n        lines = content.split('\\n')\n        \n        for i, line in enumerate(lines):\n            line = line.strip()\n            if line.startswith(('1.', '2.', '3.', '4.', '5.', '6.', '7.', '8.', '9.')):\n                steps.append(line)\n            elif line.startswith(('步骤', 'Step', 'step')):\n                steps.append(line)\n            \n        return steps if steps else [\"思考过程记录\"]\n\n\nclass AGICore:\n    \"\"\"AGI核心类\"\"\"\n    \n    def __init__(self, \n                 name: str = \"AGI-System\",\n                 model: str = \"gpt-4-turbo-preview\",\n                 enable_learning: bool = True,\n                 enable_reflection: bool = True):\n        \"\"\"初始化AGI系统\"\"\"\n        self.name = name\n        self.state = AGIState.INITIALIZING\n        self.model = model\n        self.enable_learning = enable_learning\n        self.enable_reflection = enable_reflection\n        \n        # 初始化组件\n        self.memory = MemorySystem()\n        self.reasoning_engine = ReasoningEngine(model)\n        self.tools: Dict[str, ToolInterface] = {}\n        \n        # 历史记录\n        self.thought_history: List[Thought] = []\n        self.action_history: List[Action] = []\n        \n        # 配置OpenAI API\n        self._setup_openai()\n        \n        logger.info(f\"AGI系统 '{name}' 初始化完成\")\n        \n    def _setup_openai(self):\n        \"\"\"设置OpenAI API\"\"\"\n        api_key = os.getenv(\"OPENAI_API_KEY\")\n        if not api_key:\n            raise ValueError(\"请设置OPENAI_API_KEY环境变量\")\n        \n        openai.api_key = api_key\n        \n    def register_tool(self, tool: ToolInterface):\n        \"\"\"注册工具\"\"\"\n        self.tools[tool.name] = tool\n        logger.info(f\"工具 '{tool.name}' 已注册\")\n        \n    async def process(self, input_text: str, context: Dict[str, Any] = None) -> Dict[str, Any]:\n        \"\"\"处理输入并返回响应\"\"\"\n        self.state = AGIState.THINKING\n        \n        try:\n            # 1. 检索相关记忆\n            relevant_memories = await self.memory.retrieve(input_text, limit=5)\n            memory_context = {\n                \"relevant_memories\": [\n                    {\"content\": m.content, \"category\": m.category, \"importance\": m.importance}\n                    for m in relevant_memories\n                ]\n            }\n            \n            # 2. 构建完整上下文\n            full_context = {\n                \"input\": input_text,\n                \"memories\": memory_context,\n                \"previous_actions\": self._get_recent_actions(5),\n                \"system_context\": context or {}\n            }\n            \n            # 3. 进行深度思考\n            thought = await self.reasoning_engine.think(input_text, full_context)\n            self.thought_history.append(thought)\n            \n            # 4. 决定行动\n            self.state = AGIState.EXECUTING\n            action = await self._decide_action(thought, full_context)\n            self.action_history.append(action)\n            \n            # 5. 执行行动\n            result = await self._execute_action(action)\n            \n            # 6. 学习和反思\n            if self.enable_learning:\n                await self._learn_from_experience(input_text, thought, action, result)\n                \n            if self.enable_reflection:\n                await self._reflect_on_performance(thought, action, result)\n            \n            self.state = AGIState.IDLE\n            \n            return {\n                \"thought\": asdict(thought),\n                \"action\": asdict(action),\n                \"result\": result,\n                \"state\": self.state.value\n            }\n            \n        except Exception as e:\n            self.state = AGIState.ERROR\n            logger.error(f\"处理过程失败: {e}\")\n            raise\n    \n    async def _decide_action(self, thought: Thought, context: Dict[str, Any]) -> Action:\n        \"\"\"基于思考决定行动\"\"\"\n        action_id = f\"action_{datetime.now().timestamp()}\"\n        \n        # 这里可以添加更复杂的决策逻辑\n        # 目前简单返回一个推理行动\n        \n        return Action(\n            id=action_id,\n            type=\"reasoning\",\n            description=\"基于思考生成响应\",\n            parameters={\n                \"thought_id\": thought.id,\n                \"context\": context\n            },\n            expected_outcome=\"生成有洞察力的响应\",\n            timestamp=datetime.now()\n        )\n    \n    async def _execute_action(self, action: Action) -> Dict[str, Any]:\n        \"\"\"执行行动\"\"\"\n        if action.type == \"reasoning\":\n            # 基于思考内容生成最终响应\n            thought_id = action.parameters.get(\"thought_id\")\n            thought = next((t for t in self.thought_history if t.id == thought_id), None)\n            \n            if thought:\n                # 使用思考内容生成精炼的响应\n                client = AsyncOpenAI()\n                response = await client.chat.completions.create(\n                    model=self.model,\n                    messages=[\n                        {\n                            \"role\": \"system\", \n                            \"content\": \"基于思考过程生成清晰、有用的最终响应。\"\n                        },\n                        {\n                            \"role\": \"user\", \n                            \"content\": f\"思考过程:\\n{thought.content}\\n\\n请生成最终响应：\"\n                        }\n                    ],\n                    max_tokens=1000,\n                    temperature=0.7\n                )\n                \n                return {\n                    \"type\": \"response\",\n                    \"content\": response.choices[0].message.content,\n                    \"success\": True\n                }\n            \n        elif action.type == \"tool_use\" and action.parameters.get(\"tool_name\") in self.tools:\n            # 使用工具\n            tool_name = action.parameters[\"tool_name\"]\n            tool = self.tools[tool_name]\n            \n            try:\n                result = await tool.execute(action.parameters)\n                return {\n                    \"type\": \"tool_result\",\n                    \"tool\": tool_name,\n                    \"result\": result,\n                    \"success\": True\n                }\n            except Exception as e:\n                return {\n                    \"type\": \"tool_result\",\n                    \"tool\": tool_name,\n                    \"error\": str(e),\n                    \"success\": False\n                }\n        \n        # 默认返回思考内容\n        return {\n            \"type\": \"fallback_response\",\n            \"content\": \"执行了推理行动\",\n            \"success\": True\n        }\n    \n    async def _learn_from_experience(self, input_text: str, thought: Thought, \n                                   action