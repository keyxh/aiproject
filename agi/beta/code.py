# agi

 ```json
{
  "files": [
    {
      "filename": "architecture/README.md",
      "content": "# AGI System Architecture\n\n## Overview\nThis is a modular, extensible architecture for an Artificial General Intelligence (AGI) system built on top of OpenAI API.\n\n## Core Principles\n1. **Modularity**: Each component (memory, planning, tools) is interchangeable\n2. **Scalability**: Async architecture supporting concurrent operations\n3. **Observability**: Comprehensive logging and tracing\n4. **Safety**: Built-in guardrails and human-in-the-loop mechanisms\n\n## Architecture Layers\n\n### 1. Perception Layer\n- Input processing (text, vision, audio)\n- Context window management\n- Multi-modal fusion\n\n### 2. Cognitive Layer\n- **Planner**: Hierarchical Task Network (HTN) planning with ReAct pattern\n- **Reasoner**: Chain-of-thought and tree-of-thought reasoning\n- **Reflector**: Self-evaluation and learning from mistakes\n\n### 3. Memory Layer\n- **Working Memory**: Current context and conversation history\n- **Episodic Memory**: Past experiences and interactions (Vector DB)\n- **Semantic Memory**: Knowledge graph and facts\n- **Procedural Memory**: Learned skills and patterns\n\n### 4. Action Layer\n- Tool registry and execution\n- API integrations\n- Code execution sandbox\n- External environment interaction\n\n### 5. Meta-Cognition Layer\n- Goal management\n- Resource allocation\n- Self-modification (prompt optimization)\n\n## Data Flow\n```\nInput -> Perception -> Working Memory -> Planner -> Reasoner -> Action -> Reflection -> Memory Storage\n```\n\n## Design Patterns Used\n- **Agent Pattern**: Autonomous agent with sense-think-act cycle\n- **Repository Pattern**: Abstracted data access for memory systems\n- **Strategy Pattern**: Pluggable tools and reasoning strategies\n- **Observer Pattern**: Event-driven architecture for monitoring\n"
    },
    {
      "filename": "core/interfaces.py",
      "content": "\"\"\"\nCore interfaces and abstract base classes for the AGI system.\nDefines contracts that all implementations must follow.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Dict, List, Optional, AsyncGenerator, Callable\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom datetime import datetime\nimport uuid\n\n\nclass MessageRole(Enum):\n    SYSTEM = \"system\"\n    USER = \"user\"\n    ASSISTANT = \"assistant\"\n    TOOL = \"tool\"\n    OBSERVATION = \"observation\"\n\n\n@dataclass\nclass Message:\n    \"\"\"Standard message format for all communications.\"\"\"\n    content: str\n    role: MessageRole\n    id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    timestamp: datetime = field(default_factory=datetime.now)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    attachments: List[Dict[str, Any]] = field(default_factory=list)\n\n\n@dataclass\nclass Thought:\n    \"\"\"Represents a step in the reasoning process.\"\"\"\n    content: str\n    thought_type: str  # \"reasoning\", \"planning\", \"reflection\", \"observation\"\n    confidence: float = 1.0\n    timestamp: datetime = field(default_factory=datetime.now)\n\n\n@dataclass\nclass Action:\n    \"\"\"Represents an action to be executed.\"\"\"\n    tool_name: str\n    parameters: Dict[str, Any]\n    id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    description: str = \"\"\n\n\n@dataclass\nclass Observation:\n    \"\"\"Result of executing an action.\"\"\"\n    action_id: str\n    result: Any\n    success: bool\n    timestamp: datetime = field(default_factory=datetime.now)\n    error_message: Optional[str] = None\n\n\nclass BaseMemory(ABC):\n    \"\"\"Abstract base class for all memory types.\"\"\"\n    \n    @abstractmethod\n    async def store(self, key: str, value: Any, metadata: Optional[Dict] = None) -> None:\n        \"\"\"Store information in memory.\"\"\"\n        pass\n    \n    @abstractmethod\n    async def retrieve(self, query: str, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"Retrieve relevant information based on query.\"\"\"\n        pass\n    \n    @abstractmethod\n    async def forget(self, key: str) -> None:\n        \"\"\"Remove specific information from memory.\"\"\"\n        pass\n    \n    @abstractmethod\n    async def clear(self) -> None:\n        \"\"\"Clear all memory.\"\"\"\n        pass\n\n\nclass BaseTool(ABC):\n    \"\"\"Abstract base class for tools.\"\"\"\n    \n    name: str = \"\"\n    description: str = \"\"\n    parameters: Dict[str, Any] = {}\n    \n    @abstractmethod\n    async def execute(self, **kwargs) -> Any:\n        \"\"\"Execute the tool with given parameters.\"\"\"\n        pass\n    \n    def get_schema(self) -> Dict[str, Any]:\n        \"\"\"Return OpenAI function calling schema.\"\"\"\n        return {\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": self.name,\n                \"description\": self.description,\n                \"parameters\": self.parameters\n            }\n        }\n\n\nclass BasePlanner(ABC):\n    \"\"\"Abstract base class for task planning.\"\"\"\n    \n    @abstractmethod\n    async def create_plan(self, goal: str, context: List[Message]) -> List[Action]:\n        \"\"\"Create a sequence of actions to achieve the goal.\"\"\"\n        pass\n    \n    @abstractmethod\n    async def replan(self, current_plan: List[Action], observation: Observation) -> List[Action]:\n        \"\"\"Adjust plan based on new observations.\"\"\"\n        pass\n\n\nclass BaseReasoner(ABC):\n    \"\"\"Abstract base class for reasoning engines.\"\"\"\n    \n    @abstractmethod\n    async def reason(self, context: List[Message], thoughts: List[Thought]) -> Thought:\n        \"\"\"Generate next reasoning step.\"\"\"\n        pass\n    \n    @abstractmethod\n    async def reflect(self, history: List[Thought], outcome: Any) -> Thought:\n        \"\"\"Reflect on past actions and outcomes.\"\"\"\n        pass\n\n\nclass BaseModelClient(ABC):\n    \"\"\"Abstract base class for LLM clients.\"\"\"\n    \n    @abstractmethod\n    async def chat(self, messages: List[Message