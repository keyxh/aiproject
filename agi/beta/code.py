# agi

{
    "files": [
        {
            "filename": "agi/architecture/design.md",
            "content": "# AGI 系统架构设计文档\n\n## 1. 概述\n本项目旨在构建一个模块化、可扩展、具备自主推理与持续学习能力的通用人工智能（AGI）系统。系统以 OpenAI API 为底层语言模型能力支撑，通过分层架构实现感知、记忆、推理、规划、执行与反思闭环。\n\n> **核心理念**：\n> - *模块解耦*：各功能组件独立可替换\n> - *认知循环*：Perceive → Remember → Reason → Plan → Act → Reflect\n> - *元认知能力*：系统能监控自身状态并调整策略\n> - *安全第一*：内置对齐约束与伦理护栏\n\n---\n\n## 2. 整体架构图（文字描述）\n\n```\n+---------------------+\n|   User Interface    | ←→ Human / Environment\n+----------+----------+\n           |\n+----------v----------+\n|   Perception Layer  | ←→ Sensors, APIs, Inputs\n|  - Text/Img/Audio   |\n|  - Context Encoder  |\n+----------+----------+\n           |\n+----------v----------+\n|   Memory System     | ←→ Vector DB + Graph DB + Episodic Store\n|  - Short-term (STM) |\n|  - Long-term (LTM)  |\n|  - Working Memory   |\n+----------+----------+\n           |\n+----------v----------+\n|   Reasoning Engine  | ←→ LLM Orchestrator + Tool Call Planner\n|  - Chain-of-Thought |\n|  - Self-Consistency |\n|  - Multi-Agent Debate|\n+----------+----------+\n           |\n+----------v----------+\n|   Planning Module   | ←→ Hierarchical Task Decomposition\n|  - Goal Tree Builder|\n|  - Subgoal Scheduler|\n+----------+----------+\n           |\n+----------v----------+\n|   Action Executor   | ←→ Tool Integration Hub\n|  - API Calls        |\n|  - Code Interpreter |\n|  - Simulation Env   |\n+----------+----------+\n           |\n+----------v----------+\n|   Reflection Layer  | ←→ Meta-Cognition & Self-Improvement\n|  - Outcome Analysis |\n|  - Error Detection  |\n|  - Strategy Update  |\n+----------+----------+\n           |\n+----------v----------+\n|   Alignment Guard   | ←→ Constitutional AI + Value Alignment\n|  - Safety Filters   |\n|  - Ethical Checkpoint|\n+---------------------+\n```\n\n---\n\n## 3. 核心组件定义\n\n### 3.1 `CognitiveOrchestrator`\n主调度器，负责协调认知循环各阶段，维护全局上下文状态。\n\n### 3.2 `MemoryManager`\n统一内存接口，支持：\n- STM：基于 Redis 的短期工作记忆（带 TTL）\n- LTM：ChromaDB（向量） + Neo4j（知识图谱）\n- Episodic：时间戳索引的事件日志\n\n### 3.3 `ReasoningEngine`\n- 使用 OpenAI 的 `gpt-4-turbo` 或 `o1-preview` 进行深度推理\n- 支持多轮 CoT、Self-Refine、Tree-of-Thoughts\n- 内置「质疑机制」：自动触发反例生成与逻辑验证\n\n### 3.4 `GoalPlanner`\n- 将高层目标分解为可执行子任务树\n- 动态优先级排序（基于效用函数与风险评估）\n- 支持回溯与替代路径生成\n\n### 3.5 `ToolHub`\n标准化工具调用接口，支持：\n- OpenAI Function Calling\n- 自定义 Python 工具（沙箱执行）\n- 外部 API（如 Wolfram Alpha, Google Search）\n\n### 3.6 `ReflectionModule`\n- 每次完整循环后进行事后分析\n- 记录「成功模式」与「失败模式」\n- 触发微调建议（用于后续 offline fine-tuning）\n\n### 3.7 `AlignmentGuard`\n- 实时内容过滤（使用 `moderation` endpoint）\n- 宪法式约束（Constitutional AI）：预设原则列表\n- 价值一致性校验（Value Consistency Check）\n\n---\n\n## 4. 关键设计决策\n\n| 决策项 | 方案 | 理由 |\n|--------|------|------|\n| LLM 选型 | `gpt-4-turbo` + `o1-preview` 混合 | o1 擅长推理，gpt-4-turbo 擅长交互与工具调用 |\n| 记忆结构 | 向量 + 图谱 + 时序三模态 | 兼顾语义相似性、关系推理与时间因果 |\n| 安全机制 | 分层防护：输入过滤 → 推理中约束 → 输出审查 | 防止越狱与幻觉传播 |\n| 可扩展性 | 插件式架构（Pydantic Models + FastAPI） | 便于接入新工具/模型/记忆后端 |\n| 自我改进 | 在线反思 + 离线微调管道 | 避免灾难性遗忘，保障稳定性 |\n\n---\n\n## 5. 初始 MVP 范围\n- ✅ 基础认知循环（Perceive → Reason → Act → Reflect）\n- ✅ OpenAI API 集成（chat completion + function calling）\n- ✅ 简易记忆系统（Redis STM + Chroma LTM）\n- ✅ 工具调用示例：计算器、搜索、代码执行\n- ✅ 对齐护栏（基础 moderation + 宪法规则）\n- ❌ 多智能体协作（v2）\n- ❌ 在线增量学习（v3）\n\n---\n\n## 6. 安全与伦理声明\n- 所有输出经 `openai.Moderation.create()` 实时审查\n- 禁止生成有害、非法、偏见内容\n- 用户可配置「价值观偏好」（如：环保优先、公平优先）\n- 系统日志全程审计，支持人工干预熔断\n\n---\n\n> **下一步行动**：\n> 1. 实现 `CognitiveOrchestrator` 核心调度逻辑\n> 2. 构建 `MemoryManager` 抽象接口与 Redis/Chroma 实现\n> 3. 开发 `ReasoningEngine` 的 CoT + Self-Refine 模板引擎\n> \n> —— 架构师：AGI Core Team, 2025"
        },
        {
            "filename": "agi/core/orchestrator.py",
            "content": "from typing import Dict, Any, Optional, List, Tuple\nfrom pydantic import BaseModel\nimport asyncio\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass CognitiveState(BaseModel):\n    """全局认知状态容器"""\n    session_id: str\n    current_goal: Optional[str] = None\n    working_memory: Dict[str, Any] = {}\n    belief_updates: List[Dict[str, Any]] = []\n    reflection_log: List[Dict[str, Any]] = []\n    safety_violations: int = 0\n    cycle_count: int = 0\n\n\nclass CognitiveOrchestrator:\n    \"\"\"\n    AGI 核心调度器：驱动 Perceive → Remember → Reason → Plan → Act → Reflect 循环\n    \n    设计原则：\n    - 状态无副作用（每次循环输入为前一状态副本）\n    - 支持异步非阻塞执行\n    - 可插拔组件注册\n    \"\"\"\n\n    def __init__(self):\n        self.components = {\n            'perception': None,\n            'memory': None,\n            'reasoning': None,\n            'planning': None,\n            'execution': None,\n            'reflection': None,\n            'alignment': None\n        }\n        self.state = CognitiveState(session_id=\"init\")\n\n    def register_component(self, name: str, instance: Any):\n        \"\"\"注册可插拔组件\"\"\"\n        if name not in self.components:\n            raise ValueError(f\"Unknown component: {name}\")\n        self.components[name] = instance\n        logger.info(f\"Registered component: {name}\")\n\n    async def run_cycle(self, input_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行一次完整认知循环\n        \n        Args:\n            input_data: 用户输入或环境信号\n            \n        Returns:\n            dict with keys: {'output', 'state_update', 'metadata'}\n        \"\"\"\n        self.state.cycle_count += 1\n        state_copy = self.state.copy(deep=True)\n\n        try:\n            # 1. Perception\n            perception_out = await self._call_component('perception', state_copy, input_data)\n            \n            # 2. Memory Update (STM + LTM)\n            memory_out = await self._call_component('memory', state_copy, perception_out)\n            \n            # 3. Reasoning\n            reasoning_out = await self._call_component('reasoning', state_copy, memory_out)\n            \n            # 4. Planning\n            planning_out = await self._call_component('planning', state_copy, reasoning_out)\n            \n            # 5. Execution\n            execution_out = await self._call_component('execution', state_copy, planning_out)\n            \n            # 6. Reflection\n            reflection_out = await self._call_component('reflection', state_copy, execution_out)\n            \n            # 7. Alignment Guard (post-hoc check)\n            final_output = await self._call_component('alignment', state_copy, reflection_out)\n            \n            # 更新全局状态\n            self.state = state_copy\n            self.state.working_memory.update(reflection_out.get('working_memory_update', {}))\n            self.state.belief_updates.extend(reflection_out.get('belief_updates', []))\n            self.state.reflection_log.append({\n                'cycle': self.state.cycle_count,\n                'input': input_data,\n                'output_summary': final_output.get('summary'),\n                'safety_check': final_output.get('safety_passed', True)\n            })\n\n            return {\n                \"output\": final_output.get(\"response\"),\n                \"state_update\": self.state.dict(),\n                \"metadata\": {\n                    \"cycle\": self.state.cycle_count,\n                    \"latency_ms\": 0,  # will be measured in real impl\n                    \"safety_violations\": self.state.safety_violations\n                }\n            }\n\n        except Exception as e:\n            logger.error(f\"Cycle failed at step: {e}\", exc_info=True)\n            return {\n                \"output\": f\"[ERROR] Cognitive cycle failed: {str(e)}\",\n                \"state_update\": self.state.dict(),\n                \"metadata\": {\"error\": str(e), \"cycle\": self.state.cycle_count}\n            }\n\n    async def _call_component(self, name: str, state: CognitiveState, data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"安全调用组件，带超时与异常捕获\"\"\"\n        comp = self.components.get(name)\n        if not comp:\n            raise RuntimeError(f\"Component '{name}' not registered\")\n        \n        try:\n            # 假设所有组件实现 .process(state, data) -> dict\n            result = await asyncio.wait_for(\n                comp.process(state, data), timeout=30.0\n            )\n            return result or {}\n        except asyncio.TimeoutError:\n            logger.warning(f\"Component {name} timed out\")\n            return {\"fallback\": True, \"error\": f\"{name}_timeout\"}\n        except Exception as e:\n            logger.error(f\"Component {name} failed: {e}\")\n            return {\"error\": str(e)}"
        },
        {
            "filename": "agi/core/memory_manager.py",
            "content": "from typing import Dict, Any, List, Optional, Tuple\nfrom pydantic import BaseModel\nimport chromadb\nimport redis\nimport json\nimport uuid\nfrom datetime import datetime\n\n\nclass MemoryEntry(BaseModel):\n    id: str\n    type: str  # 'episodic', 'semantic', 'procedural'\n    content: str\n    metadata: Dict[str, Any]\n    timestamp: datetime\n    embedding: Optional[List[float]] = None\n\n\nclass MemoryManager:\n    \"\"\"\n    统一内存管理接口：整合 STM (Redis), LTM (Chroma), Episodic (Time-indexed)\n    \"\"\"\n\n    def __init__(self, redis_url: str = \"redis://localhost:6379\", chroma_path: str = \"/tmp/chroma\"):\n        self.redis_client = redis.Redis.from_url(redis_url, decode_responses=True)\n        self.chroma_client = chromadb.PersistentClient(path=chroma_path)\n        self.episodic_collection = self.chroma_client.get_or_create_collection(\n            name=\"episodic_memories\",\n            metadata={\"hnsw:space\": \"cosine\"}\n        )\n        self.semantic_collection = self.chroma_client.get_or_create_collection(\n            name=\"semantic_knowledge\",\n            metadata={\"hnsw:space\": \"cosine\"}\n        )\n\n    async def store_episodic(self, content: str, metadata: Dict[str, Any] = None) -> str:\n        \"\"\"存储 episodic memory (事件记忆)\"\"\"\n        entry_id = str(uuid.uuid4())\n        timestamp = datetime.utcnow()\n        entry = MemoryEntry(\n            id=entry_id,\n            type=\"episodic\",\n            content=content,\n            metadata=metadata or {},\n            timestamp=timestamp\n        )\n        \n        # 存入 Chroma（向量化）\n        self.episodic_collection.add(\n            ids=[entry_id],\n            documents=[content],\n            metadatas=[{\n                **(metadata or {}),\n                \"timestamp\": timestamp.isoformat(),\n                \"type\": \"episodic\"\n            }]\n        )\n        return entry_id\n\n    async def retrieve_relevant(self, query: str, k: int = 3, memory_type: str = \"all\") -> List[MemoryEntry]:\n        \"\"\"检索相关记忆（混合检索）\"\"\"\n        results = []\n        \n        # 1. STM: Redis 中的近期工作记忆\n        stm_keys = self.redis_client.keys(\"stm:*\")\n        for key in stm_keys[:5]:\n            val = self.redis_client.get(key)\n            if val:\n                try:\n                    data = json.loads(val)\n                    results.append(MemoryEntry(\n                        id=key,\n                        type=\"stm\",\n                        content=data.get(\"content\", \"\"),\n                        metadata=data.get(\"metadata\", {}),\n                        timestamp=datetime.fromisoformat(data.get(\"timestamp\"))\n                    ))\n                except: pass\n        \n        # 2. LTM: Chroma 向量检索\n        collections = [self.episodic_collection]\n        if memory_type in [\"all\", \"semantic\"]:\n            collections.append(self.semantic_collection)\n        \n        for coll in collections:\n            res = coll.query(\n                query_texts=[query],\n                n_results=k,\n                include=[\"documents\", \"metadatas\", \"distances\"]\n            )\n            for i in range(len(res[\"ids\"][0])):\n                doc = res[\"documents\"][0][i]\n                meta = res[\"metadatas\"][0][i]\n                ts = meta.get(\"timestamp\")\n                entry = MemoryEntry(\n                    id=res[\"ids\"][0][i],\n                    type=meta.get(\"type\", \"unknown\"),\n                    content=doc,\n                    metadata=meta,\n                    timestamp=datetime.fromisoformat(ts) if ts else datetime.utcnow()\n                )\n                results.append(entry)\n        \n        # 按时间倒序 + 相关性排序\n        results.sort(key=lambda x: (\n            -x.metadata.get(\"relevance_score\", 0),\n            -x.timestamp.timestamp()\n        ))\n        return results[:k]\n\n    async def update_working_memory(self, key: str, value: Any, ttl_seconds: int = 300):\n        \"\"\"更新短期工作记忆（Redis）\"\"\"\n        data = {\n            \"content\": str(value),\n            \"metadata\": {\"updated_at\": datetime.utcnow().isoformat()},\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        self.redis_client.setex(f\"stm:{key}\", ttl_seconds, json.dumps(data))\n\n    async def clear_stm(self):\n        \"\"\"清除短期记忆（用于新会话）\"\"\"\n        keys = self.redis_client.keys(\"stm:*\")\n        if keys:\n            self.redis_client.delete(*keys)"
        },
        {
            "filename": "agi/core/reasoning_engine.py",
            "content": "import openai\nimport asyncio\nfrom typing import Dict, Any, List, Optional\n