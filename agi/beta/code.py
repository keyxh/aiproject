# agi

{
    "files": [
        {
            "filename": "agi/architecture/design.md",
            "content": "# AGI 系统架构设计文档\n\n## 1. 概述\n本项目旨在构建一个具备通用认知能力的AGI（Artificial General Intelligence）系统，基于模块化、可扩展、可验证的设计原则，通过组合感知、记忆、推理、规划与执行等核心能力模块，实现跨领域任务的自主理解与解决。\n\n> **关键理念**：\n> - *分层认知架构*：模拟人类心智的感知-记忆-推理-行动闭环\n> - *工具增强智能*：通过API调用外部工具（如OpenAI API、搜索引擎、代码执行器）扩展能力边界\n> - *自我反思与元学习*：支持运行时策略优化与经验内化\n> - *安全对齐优先*：内置价值对齐、意图澄清、风险拦截机制\n\n## 2. 核心架构组件\n\n### 2.1 认知引擎（Cognitive Engine）\n主控调度中心，负责任务分解、上下文管理、模块路由与决策仲裁。\n\n### 2.2 感知模块（Perception Module）\n- 输入解析：文本/图像/语音（当前以文本为主）\n- 意图识别：使用LLM进行语义分类与目标抽取\n- 上下文摘要：动态维护短期记忆摘要\n\n### 2.3 记忆系统（Memory System）\n- **短期记忆（Working Memory）**：Redis缓存，存储当前会话状态、变量、中间结果\n- **长期记忆（Episodic & Semantic Memory）**：向量数据库（如ChromaDB），支持语义检索与经验复用\n- **技能库（Skill Library）**：结构化知识库，存储已习得的“技能模板”（如“写Python脚本”、“分析数据”）\n\n### 2.4 推理与规划模块（Reasoning & Planning）\n- **链式推理（Chain-of-Thought）**：多步逻辑推导\n- **树搜索规划（Tree-of-Thought / Tree-of-Plans）**：生成并评估多个行动路径\n- **反事实推理**：评估不同决策后果\n- **工具调用规划器**：决定何时/如何调用外部工具（含OpenAI API）\n\n### 2.5 执行与反馈模块（Execution & Feedback）\n- 工具调用代理（Tool Agent）：封装OpenAI API调用、代码解释器、HTTP客户端等\n- 执行沙箱：安全隔离的代码执行环境（如Dockerized Python REPL）\n- 结果验证器：对输出进行一致性、安全性、有效性校验\n- 反馈回路：将执行结果与预期对比，触发反思或重试\n\n### 2.6 元认知与学习模块（Metacognition & Learning）\n- **反思器（Reflector）**：分析失败案例，生成改进策略\n- **经验压缩器**：将成功会话提炼为可复用的“技能片段”\n- **对齐监督器（Alignment Monitor）**：实时检测价值观偏离（如偏见、有害指令），触发干预\n\n## 3. 技术栈选型\n\n| 层级 | 组件 | 选型 |\n|------|------|------|\n| 前端接口 | REST/gRPC API | FastAPI |\n| 核心引擎 | 调度与控制流 | Python + LangChain（轻量定制） |\n| LLM 接口 | OpenAI API 封装 | `openai` SDK + 自定义 RateLimiter / Retry / Cost Tracker |\n| 记忆存储 | 向量库 | ChromaDB（本地） / Pinecone（云） |\n| 缓存 | 工作记忆 | Redis |\n| 安全沙箱 | 代码执行 | ` RestrictedPython` + Docker container |\n| 监控 | 日志/指标/追踪 | Prometheus + Grafana + OpenTelemetry |\n\n## 4. 关键设计模式\n\n### 4.1 “思维流”抽象（Thought Stream Abstraction）\n所有内部状态以结构化 JSON 流形式传递：\n```json\n{\n  \"id\": \"ts_123\",\n  \"step\": \"planning\",\n  \"context\": {\"task\": \"分析用户情绪\", \"history\": [...]},\n  \"reasoning\": [\"步骤1: 提取关键词\", \"步骤2: 匹配情感词典\"],\n  \"tools\": [{\"name\": \"openai-chat\", \"params\": {...}}],\n  \"confidence\": 0.87,\n  \"trace_id\": \"tr_abc\"\n}\n```\n\n### 4.2 可插拔工具协议（Pluggable Tool Protocol）\n工具需实现统一接口：\n```python\nclass Tool:\n    name: str\n    description: str\n    schema: dict  # JSON Schema for input\n    \n    def invoke(self, input: dict) -> dict:\n        \"\"\"返回 {\"result\": ..., \"metadata\": {...}}\"\"\"\n```\n\n### 4.3 安全护栏（Safety Guardrails）\n- **输入过滤层**：敏感词+意图检测（调用专用小模型）\n- **输出审查层**：生成后校验（使用独立裁判LLM或规则引擎）\n- **权限分级**：用户角色 → 工具访问白名单\n- **人工接管点**：高风险操作需确认或转人工\n\n## 5. 初版 MVP 架构图（文字描述）\n\n```
[User Input] \n     ↓\n[Cognitive Engine] ←→ [Working Memory (Redis)]\n     │\n     ├─→ [Perception] → Intent/Context Extraction\n     ├─→ [Planning] → Generate Action Plan (ToT)\n     │        ↓\n     │   [Tool Selector] → [OpenAI API Proxy]\n     │        │                ↓\n     │        └→ [Code Sandbox] ←→ [Long-term Memory (Chroma)]\n     │\n     └─→ [Execution] → Run Tools → Validate → Return Result\n                ↓\n         [Reflector] → Update Skills / Memory / Policies\n                ↓\n         [Alignment Monitor] → Block or Sanitize if Unsafe
```

## 6. 开发路线图（Phase 1: MVP）\n\n| 阶段 | 目标 | 交付物 |\n|------|------|--------|\n| Phase 0 | 架构落地 | 本设计文档 + 模块接口规范 |\n| Phase 1 | 核心循环 | 支持单轮任务：输入→理解→调用OpenAI→输出→记忆存储 |\n| Phase 2 | 记忆增强 | 实现长期记忆检索与经验复用 |\n| Phase 3 | 规划能力 | 支持多步任务分解与工具链编排 |\n| Phase 4 | 自我改进 | 加入反思与技能学习模块 |\n| Phase 5 | 安全对齐 | 部署完整护栏与人工接管机制 |\n\n---\n\n> **备注**：本设计避免过度依赖单一LLM，强调“LLM as a component”，而非“LLM as the brain”。真正的AGI应是**认知架构驱动 + LLM赋能**的混合系统。\n\n*Architect: AGI Core Team | Date: 2024-06-15*"
        },
        {
            "filename": "agi/core/cognitive_engine.py",
            "content": "from typing import Dict, Any, Optional, List, Tuple\nimport uuid\nimport json\nimport logging\nfrom datetime import datetime\n\n# 假设已定义的模块\nfrom agi.memory.working_memory import WorkingMemory\nfrom agi.memory.long_term import LongTermMemory\nfrom agi.perception import PerceptionModule\nfrom agi.planning import PlanningModule\nfrom agi.execution import ExecutionModule\nfrom agi.reflection import Reflector\nfrom agi.safety import AlignmentMonitor\n\nlogger = logging.getLogger(__name__)\n\n\nclass CognitiveEngine:\n    \"\"\"\n    AGI核心认知引擎：协调感知、记忆、规划、执行、反思与安全监控\n    遵循‘思维流’抽象，支持可追溯、可审计的认知过程\n    \"\"\"\n\n    def __init__(\n        self,\n        working_memory: WorkingMemory,\n        long_term_memory: LongTermMemory,\n        perception: PerceptionModule,\n        planning: PlanningModule,\n        execution: ExecutionModule,\n        reflector: Reflector,\n        alignment_monitor: AlignmentMonitor,\n        max_thought_steps: int = 20\n    ):\n        self.working_memory = working_memory\n        self.long_term_memory = long_term_memory\n        self.perception = perception\n        self.planning = planning\n        self.execution = execution\n        self.reflector = reflector\n        self.alignment_monitor = alignment_monitor\n        self.max_thought_steps = max_thought_steps\n        self.trace_log = []  # 用于调试与审计\n\n    async def process_input(self, user_input: str, session_id: str = None) -> Dict[str, Any]:\n        \"\"\"\n        主入口：处理用户输入，返回结构化响应\n        \"\"\"\n        trace_id = str(uuid.uuid4())\n        session_id = session_id or str(uuid.uuid4())\n        start_time = datetime.utcnow()\n\n        # 初始化工作记忆\n        await self.working_memory.init_session(session_id, {\n            \"user_input\": user_input,\n            \"session_start\": start_time.isoformat(),\n            \"trace_id\": trace_id,\n            \"step_count\": 0,\n            \"status\": \"running\"\n        })\n\n        try:\n            # Step 1: 感知 — 解析输入与上下文\n            perception_result = await self.perception.analyze(\n                user_input=user_input,\n                session_id=session_id\n            )\n            await self.working_memory.update(session_id, {\n                \"perception\": perception_result,\n                \"current_context\": perception_result.get(\"context\", {})\n            })\n\n            # Step 2: 安全初筛\n            safety_check = await self.alignment_monitor.check_input(\n                input_text=user_input,\n                context=perception_result\n            )\n            if not safety_check[\"safe\"]:\n                return {\n                    \"status\": \"blocked\",\n                    \"reason\": safety_check[\"reason\"],\n                    \"trace_id\": trace_id\n                }\n\n            # Step 3: 规划 — 生成行动路径\n            plan = await self.planning.generate_plan(\n                goal=perception_result[\"intent\"],\n                context=perception_result[\"context\"],\n                session_id=session_id\n            )\n            await self.working_memory.update(session_id, {\"plan\": plan})\n\n            # Step 4: 执行循环（最多 max_thought_steps 步）\n            result = None\n            for step in range(1, self.max_thought_steps + 1):\n                await self.working_memory.update(session_id, {\"step_count\": step})\n\n                # 执行当前计划步骤\n                execution_result = await self.execution.execute_step(\n                    plan_step=plan.get(\"steps\", [])[step-1] if step <= len(plan.get(\"steps\", [])) else None,\n                    context=await self.working_memory.get(session_id),\n                    session_id=session_id\n                )\n\n                # 更新工作记忆\n                await self.working_memory.update(session_id, {\n                    f\"step_{step}\": execution_result,\n                    \"last_execution\": execution_result\n                })\n\n                # 安全后审\n                post_safety = await self.alignment_monitor.check_output(\n                    output=execution_result.get(\"result\"),\n                    context=await self.working_memory.get(session_id)\n                )\n                if not post_safety[\"safe\"]:\n                    return {\n                        \"status\": \"sanitized\",\n                        \"original\": execution_result.get(\"result\"),\n                        \"sanitized\": post_safety[\"suggestion\"],\n                        \"reason\": post_safety[\"reason\"],\n                        \"trace_id\": trace_id\n                    }\n\n                # 检查是否完成\n                if execution_result.get(\"completed\", False):\n                    result = execution_result\n                    break\n\n            # Step 5: 反思与记忆固化\n            if result:\n                reflection = await self.reflector.reflect(\n                    session_id=session_id,\n                    final_result=result,\n                    plan=plan\n                )\n                await self.working_memory.update(session_id, {\"reflection\": reflection})\n\n                # 将成功经验存入长期记忆\n                if reflection.get(\"success\"):\n                    await self.long_term_memory.store_episode(\n                        session_id=session_id,\n                        episode={\n                            \"input\": user_input,\n                            \"goal\": perception_result[\"intent\"],\n                            \"plan\": plan,\n                            \"result\": result[\"result\"],\n                            \"reflection\": reflection,\n                            \"timestamp\": datetime.utcnow().isoformat()\n                        }\n                    )\n\n            # 构建最终响应\n            response = {\n                \"status\": \"success\" if result else \"partial\",\n                \"result\": result[\"result\"] if result else None,\n                \"trace_id\": trace_id,\n                \"session_id\": session_id,\n                \"steps_taken\": step,\n                \"memory_updated\": bool(result),\n                \"metadata\": {\n                    \"processing_time\": (datetime.utcnow() - start_time).total_seconds(),\n                    \"model_calls\": result.get(\"model_calls\", 0) if result else 0\n                }\n            }\n\n            return response\n\n        except Exception as e:\n            logger.error(f\"CognitiveEngine error in session {session_id}: {e}\", exc_info=True)\n            await self.working_memory.update(session_id, {\"error\": str(e), \"status\": \"failed\"})\n            return {\n                \"status\": \"error\",\n                \"error\": str(e),\n                \"trace_id\": trace_id\n            }\n\n    async def get_trace(self, session_id: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取完整思维流轨迹（用于调试与可解释性）\n        \"\"\"\n        wm = await self.working_memory.get(session_id)\n        return self._extract_trace_from_memory(wm)\n\n    def _extract_trace_from_memory(self, wm: Dict[str, Any]) -> List[Dict[str, Any]]:\n        trace = []\n        for key, value in wm.items():\n            if key.startswith(\"step_\") and isinstance(value, dict):\n                trace.append({\n                    \"step\": key,\n                    \"time\": value.get(\"timestamp\", \"N/A\"),\n                    \"action\": value.get(\"action\"),\n                    \"result\": value.get(\"result\"),\n                    \"confidence\": value.get(\"confidence\")\n                })\n        return sorted(trace, key=lambda x: x[\"step\"])\n\n# 使用示例（非运行代码，仅示意）\n# engine = CognitiveEngine(...)\n# resp = await engine.process_input(\"如何用Python分析CSV中的销售趋势？\")"
        },
        {
            "filename": "agi/tools/openai_tool.py",
            "content": "from typing import Dict, Any, Optional\nimport openai\nimport os\nimport asyncio\nimport logging\nfrom tenacity import retry, stop_after_attempt, wait_exponential, before_sleep_log\n\nlogger = logging.getLogger(__name__)\n\n\nclass OpenAITool:\n    \"\"\"\n    封装 OpenAI API 调用，作为可插拔工具组件\n    支持 chat/completions 与 function calling 模式\n    \"\"\"\n\n    def __init__(self, api_key: str = None, model: str = \"gpt-4-turbo\", timeout: int = 30):\n        self.api_key = api_key or os.getenv(\"OPENAI_API_KEY\")\n        if not self.api_key:\n            raise ValueError(\"OPENAI_API_KEY not set\")\n        openai.api_key = self.api_key\n        self.model = model\n        self.timeout = timeout\n        self.client = openai.AsyncOpenAI(api_key=self.api_key)\n\n    @retry(\n        stop=stop_after_attempt(3),\n        wait=wait_exponential(multiplier=1, min=4, max=10),\n        before_sleep=before_sleep_log(logger, logging.WARNING)\n    )\n    async def invoke(\n        self,\n        prompt: str = None,\n        messages: list = None,\n        functions: list = None,\n        function_call: str = \"auto\",\n        temperature: float = 0.7,\n        max_tokens: int = 1024,\n        metadata: Dict[str, Any] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        调用 OpenAI API\n        支持两种模式：\n          - 若提供 `prompt`：使用 completion 模式（兼容旧版）\n          - 若提供 `messages`：使用 chat 模式（推荐）\n        \"\"\"\n        try:\n            start_time = asyncio.get_event_loop().time()\n\n            if messages is None and prompt:\n                # Legacy completion mode\n                response = await self.client.completions.create(\n                    model=self.model,\n                    prompt=prompt,\n                    temperature=temperature,\n                    max_tokens