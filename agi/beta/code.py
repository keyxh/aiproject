# agi

 ```json
{
  "files": [
    {
      "filename": "config/settings.py",
      "content": "\"\"\"\n项目配置管理\n使用Pydantic Settings管理环境变量和配置\n\"\"\"\nfrom pydantic_settings import BaseSettings\nfrom pydantic import Field\nfrom typing import Optional\n\n\nclass Settings(BaseSettings):\n    \"\"\"AGI系统配置类\"\"\"\n    \n    # OpenAI配置\n    openai_api_key: str = Field(..., description=\"OpenAI API密钥\")\n    openai_model: str = Field(\"gpt-4\", description=\"使用的模型名称\")\n    openai_base_url: Optional[str] = Field(None, description=\"自定义API基础URL\")\n    \n    # 系统配置\n    max_iterations: int = Field(10, description=\"单次任务最大迭代次数\")\n    temperature: float = Field(0.7, description=\"模型温度参数\")\n    max_tokens: int = Field(2000, description=\"单次调用最大token数\")\n    \n    # 记忆系统配置\n    memory_limit: int = Field(10, description=\"短期记忆保留的对话轮数\")\n    vector_db_path: str = Field(\"./data/vector_db\", description=\"向量数据库路径\")\n    embedding_model: str = Field(\"text-embedding-ada-002\", description=\"嵌入模型\")\n    \n    # 反思配置\n    reflection_interval: int = Field(5, description=\"每多少步进行一次反思\")\n    \n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n\nsettings = Settings()\n"
    },
    {
      "filename": "core/memory.py",
      "content": "\"\"\"\n记忆系统实现\n包含短期工作记忆和长期向量记忆\n\"\"\"\nimport json\nimport hashlib\nfrom datetime import datetime\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass, asdict\nimport numpy as np\nfrom openai import AsyncOpenAI\nimport chromadb\nfrom chromadb.config import Settings as ChromaSettings\n\nfrom config.settings import settings\n\n\n@dataclass\nclass MemoryItem:\n    \"\"\"记忆单元\"\"\"\n    content: str\n    timestamp: datetime\n    memory_type: str  # 'observation', 'thought', 'action', 'reflection'\n    importance: float = 1.0  # 重要性评分 0-1\n    metadata: Dict[str, Any] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        data = asdict(self)\n        data['timestamp'] = self.timestamp.isoformat()\n        return data\n\n\nclass ShortTermMemory:\n    \"\"\"短期工作记忆 - 维护最近的对话和思考链\"\"\"\n    \n    def __init__(self, limit: int = None):\n        self.limit = limit or settings.memory_limit\n        self.buffer: List[MemoryItem] = []\n    \n    def add(self, content: str, memory_type: str = \"observation\", \n            importance: float = 1.0, metadata: Dict = None):\n        \"\"\"添加记忆到短期记忆\"\"\"\n        item = MemoryItem(\n            content=content,\n            timestamp=datetime.now(),\n            memory_type=memory_type,\n            importance=importance,\n            metadata=metadata or {}\n        )\n        self.buffer.append(item)\n        \n        # 保持记忆在限制范围内，但保留重要的记忆\n        if len(self.buffer) > self.limit:\n            # 简单策略：移除最旧且重要性低的记忆\n            self.buffer.sort(key=lambda x: (x.importance, x.timestamp))\n            self.buffer = self.buffer[-self.limit:]\n    \n    def get_recent(self, n: int = 5, memory_type: Optional[str] = None) -> List[MemoryItem]:\n        \"\"\"获取最近的记忆\"\"\"\n        items = self.buffer\n        if memory_type:\n            items = [item for item in items if item.memory_type == memory_type]\n        return items[-n:]\n    \n    def get_context_string(self, n: int = 5) -> str:\n        \"\"\"获取格式化的上下文字符串\"\"\"\n        recent = self.get_recent(n)\n        lines = []\n        for item in recent:\n            lines.append(f\"[{item.memory_type.upper()}] {item.content}\")\n        return \"\\n\".join(lines)\n    \n    def clear(self):\n        \"\"\"清空短期记忆\"\"\"\n        self.buffer = []\n\n\nclass LongTermMemory:\n    \"\"\"长期记忆 - 使用向量数据库存储和检索\"\"\"\n    \n    def __init__(self):\n        self.client = chromadb.Client(\n            ChromaSettings(\n                chroma_db_impl=\"duckdb+parquet\",\n                persist_directory=settings.vector_db_path\n            )\n        )\n        self.collection = self.client.get_or_create_collection(\n            name=\"agi_memories\",\n            metadata={\"hnsw:space\": \"cosine\"}\n        )\n        self.openai_client = AsyncOpenAI(\n            api_key=settings.openai_api_key,\n            base_url=settings.openai_base_url\n        )\n    \n    async def add(self, content: str, memory_type: str = \"observation\", \n                  metadata: Dict = None):\n        \"\"\"添加长期记忆\"\"\"\n        # 生成唯一ID\n        doc_id = hashlib.md5(\n            f\"{content}{datetime.now().isoformat()}\".encode()\n        ).hexdigest()\n        \n        # 获取embedding\n        embedding = await self._get_embedding(content)\n        \n        # 存储到向量数据库\n        self.collection.add(\n            embeddings=[embedding],\n            documents=[content],\n            metadatas=[{\n                \"type\": memory_type,\n                \"timestamp\": datetime.now().isoformat(),\n                **(metadata or {})\n            }],\n            ids=[doc_id]\n        )\n    \n    async def retrieve(self, query: str, n_results: int = 3) -> List[Dict[str, Any]]:\n        \"\"\"基于语义相似性检索记忆\"\"\"\n        query_embedding = await self._get_embedding(query)\n        \n        results = self.collection.query(\n            query_embeddings