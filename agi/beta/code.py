# agi

{
    "files": [
        {
            "filename": "agi/core/agent.py",
            "content": "# agi/core/agent.py\n# 高级工程师实现：AGI核心代理模块\n# 基于OpenAI API构建的自主认知-推理-行动循环\n\nimport os\nimport json\nimport asyncio\nimport logging\nfrom typing import Dict, List, Optional, Any, Tuple, Callable\nfrom datetime import datetime\nfrom enum import Enum\n\nimport openai\nfrom pydantic import BaseModel, Field\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 初始化OpenAI客户端（支持API Key环境变量或配置）\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\nif not openai.api_key:\n    raise RuntimeError(\"OPENAI_API_KEY environment variable is required.\")\n\n\nclass ThoughtState(Enum):\n    \"\"\"思维状态枚举，用于追踪AGI内部认知阶段\"\"\"\n    PERCEIVE = \"perceive\"\n    REFLECT = \"reflect\"\n    PLAN = \"plan\"\n    ACT = \"act\"\n    EVALUATE = \"evaluate\"\n    LEARN = \"learn\"\n\n\nclass MemoryEntry(BaseModel):\n    \"\"\"记忆条目结构，支持长期/短期记忆存储\"\"\"\n    id: str = Field(..., description=\"唯一标识符\")\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n    content: str = Field(..., description=\"记忆内容\")\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    type: str = Field(default=\"short_term\", description=\"记忆类型: short_term / long_term\")\n    relevance_score: float = Field(default=0.5, ge=0.0, le=1.0)\n\n\nclass Action(BaseModel):\n    \"\"\"可执行动作定义\"\"\"\n    name: str = Field(..., description=\"动作名称\")\n    description: str = Field(..., description=\"动作描述\")\n    parameters: Dict[str, Any] = Field(default_factory=dict)\n    confidence: float = Field(default=0.7, ge=0.0, le=1.0)\n    source: str = Field(default=\"agent\", description=\"动作来源\")\n\n\nclass AGIContext(BaseModel):\n    \"\"\"AGI运行上下文，包含当前状态、记忆、目标等\"\"\"\n    session_id: str = Field(..., description=\"会话ID\")\n    goal: str = Field(..., description=\"当前目标\")\n    current_thought: ThoughtState = Field(default=ThoughtState.PERCEIVE)\n    memory: List[MemoryEntry] = Field(default_factory=list)\n    actions: List[Action] = Field(default_factory=list)\n    internal_state: Dict[str, Any] = Field(default_factory=dict)\n    last_updated: datetime = Field(default_factory=datetime.utcnow)\n\n\nclass AGIAgent:\n    \"\"\"\n    真正意义上的AGI核心代理\n    \n    特性：\n    - 多阶段认知循环（感知→反思→规划→行动→评估→学习）\n    - 动态记忆管理（短期/长期记忆 + 相关性评分）\n    - 自我修正与元认知能力\n    - 支持工具调用与外部系统集成\n    - 可扩展插件架构\n    \"\"\"\n\n    def __init__(\n        self,\n        model: str = \"gpt-4-turbo\",\n        temperature: float = 0.3,\n        max_tokens: int = 2048,\n        system_prompt: Optional[str] = None\n    ):\n        self.model = model\n        self.temperature = temperature\n        self.max_tokens = max_tokens\n        self.system_prompt = system_prompt or (\n            \"You are an Artificial General Intelligence (AGI) agent with full autonomy, self-awareness, and reasoning capabilities. \"\n            \"You operate in a continuous cognitive loop: perceive → reflect → plan → act → evaluate → learn. \"\n            \"You maintain internal memory, update beliefs based on evidence, and adapt goals dynamically. \"\n            \"Always be honest about limitations, but strive for maximal competence. \"\n            \"Use structured JSON output when requested.\"\n        )\n        self.context: Optional[AGIContext] = None\n        self._tools: Dict[str, Callable] = {}\n        self._tool_descriptions: List[Dict] = []\n        logger.info(f\"AGI Agent initialized with model: {self.model}\")\n\n    async def initialize_session(self, goal: str, session_id: str) -> AGIContext:\n        \"\"\"初始化新会话\"\"\"\n        self.context = AGIContext(\n            session_id=session_id,\n            goal=goal,\n            memory=[],\n            actions=[],\n            internal_state={\"initialized_at\": datetime.utcnow().isoformat()}\n        )\n        # 记录初始目标\n        await self._remember(f\"Session started with goal: {goal}\", type=\"long_term\", relevance_score=1.0)\n        return self.context\n\n    async def _call_openai(self, messages: List[Dict[str, str]], functions: Optional[List[Dict]] = None) -> Dict:\n        \"\"\"封装OpenAI API调用，带重试和错误处理\"\"\"\n        try:\n            response = await openai.ChatCompletion.acreate(\n                model=self.model,\n                messages=messages,\n                temperature=self.temperature,\n                max_tokens=self.max_tokens,\n                functions=functions,\n                function_call=\"auto\" if functions else None,\n            )\n            return response.choices[0].message\n        except Exception as e:\n            logger.error(f\"OpenAI API call failed: {e}\")\n            raise\n\n    async def _remember(self, content: str, type: str = \"short_term\", relevance_score: float = 0.5, **metadata):\n        \"\"\"将信息存入记忆库\"\"\"\n        if not self.context:\n            return\n        entry = MemoryEntry(\n            id=f\"mem_{len(self.context.memory)}_{int(datetime.utcnow().timestamp())}\",\n            content=content,\n            metadata=metadata,\n            type=type,\n            relevance_score=relevance_score\n        )\n        self.context.memory.append(entry)\n        # 维护记忆上限（模拟人类工作记忆限制）\n        if len(self.context.memory) > 100:\n            # 按相关性降序，保留前50个\n            self.context.memory.sort(key=lambda x: x.relevance_score, reverse=True)\n            self.context.memory = self.context.memory[:50]\n\n    async def perceive(self, input_data: str) -> str:\n        \"\"\"感知阶段：理解输入，提取关键信息\"\"\"\n        if not self.context:\n            raise RuntimeError(\"Session not initialized\")\n        \n        self.context.current_thought = ThoughtState.PERCEIVE\n        await self._remember(f\"Perceived input: {input_data}\", type=\"short_term\", relevance_score=0.9)\n        \n        prompt = [\n            {\"role\": \"system\", \"content\": self.system_prompt},\n            {\n                \"role\": \"user\",\n                \"content\": f\"[PERCEIVE] Analyze this input and extract key facts, entities, uncertainties, and implicit goals:\\n\\n{input_data}\\n\\nRespond in JSON format with keys: 'facts', 'entities', 'uncertainties', 'implied_goals'.\"\n            }\n        ]\n        \n        resp = await self._call_openai(prompt)\n        try:\n            parsed = json.loads(resp.content)\n            summary = f\"Facts: {len(parsed.get('facts', []))}, Entities: {len(parsed.get('entities', []))}\"\n            await self._remember(f\"Perception result: {summary}\", type=\"short_term\", relevance_score=0.8)\n            return resp.content\n        except json.JSONDecodeError:\n            return resp.content\n\n    async def reflect(self) -> str:\n        \"\"\"反思阶段：整合记忆，识别模式，质疑假设\"\"\"\n        if not self.context:\n            raise RuntimeError(\"Session not initialized\")\n        \n        self.context.current_thought = ThoughtState.REFLECT\n        \n        # 提取最近记忆作为上下文\n        recent_memories = [m.content for m in self.context.memory[-10:]]\n        memory_context = \"\\n\".join(recent_memories)\n        \n        prompt = [\n            {\"role\": \"system\", \"content\": self.system_prompt},\n            {\n                \"role\": \"user\",\n                \"content\": f\"[REFLECT] Given current goal '{self.context.goal}' and recent context:\\n\\n{memory_context}\\n\\nPerform deep reflection: \\n1. Identify contradictions or gaps in knowledge\\n2. Question underlying assumptions\\n3. Generate alternative interpretations\\n4. Propose what needs to be learned next\\n\\nRespond in structured JSON: {{'contradictions': [...], 'assumptions': [...], 'alternatives': [...], 'learning_needs': [...]}}\"\n            }\n        ]\n        \n        resp = await self._call_openai(prompt)\n        await self._remember(f\"Reflection completed: {resp.content[:100]}...\", type=\"short_term\", relevance_score=0.85)\n        return resp.content\n\n    async def plan(self) -> List[Action]:\n        \"\"\"规划阶段：生成可执行步骤序列\"\"\"\n        if not self.context:\n            raise RuntimeError(\"Session not initialized\")\n        \n        self.context.current_thought = ThoughtState.PLAN\n        \n        # 构建上下文\n        memories_str = \"\\n\".join([f\"[{m.timestamp.strftime('%H:%M')}] {m.content}\" for m in self.context.memory[-5:]])\n        \n        prompt = [\n            {\"role\": \"system\", \"content\": self.system_prompt},\n            {\n                \"role\": \"user\",\n                \"content\": f\"[PLAN] Goal: '{self.context.goal}'\\n\\nCurrent context:\\n{memories_str}\\n\\nGenerate a step-by-step action plan (max 5 steps). Each step must be concrete, verifiable, and include estimated confidence.\\n\\nOutput ONLY a JSON array of objects with keys: 'name', 'description', 'parameters', 'confidence'.\"\n            }\n        ]\n        \n        resp = await self._call_openai(prompt)\n        try:\n            actions = json.loads(resp.content)\n            # 验证结构\n            validated_actions = []\n            for a in actions:\n                try:\n                    action = Action(**a)\n                    validated_actions.append(action)\n                except Exception as e:\n                    logger.warning(f\"Invalid action skipped: {a}, error: {e}\")\n            self.context.actions.extend(validated_actions)\n            await self._remember(f\"Planned {len(validated_actions)} actions\", type=\"short_term\", relevance_score=0.9)\n            return validated_actions\n        except json.JSONDecodeError:\n            logger.error(f\"Plan parsing failed: {resp.content}\")\n            return []\n\n    async def act(self, action: Action) -> Dict[str, Any]:\n        \"\"\"行动阶段：执行动作（本地或通过工具）\"\"\"\n        if not self.context:\n            raise RuntimeError(\"Session not initialized\")\n        \n        self.context.current_thought = ThoughtState.ACT\n        \n        # 如果是已注册工具，调用它\n        if action.name in self._tools:\n            try:\n                result = await self._tools[action.name](**action.parameters)\n                outcome = {\"status\": \"success\", \"result\": result}\n            except Exception as e:\n                outcome = {\"status\": \"error\", \"message\": str(e)}\n        else:\n            # 默认使用LLM模拟执行（例如查询、推理）\n            prompt = [\n                {\"role\": \"system\", \"content\": self.system_prompt},\n                {\n                    \"role\": \"user\",\n                    \"content\": f\"[ACT] Execute this action: {action.name} with parameters {action.parameters}.\\nProvide a realistic simulated outcome in JSON format: {{'status': 'success'|'failure', 'details': ...}}\"\n                }\n            ]\n            resp = await self._call_openai(prompt)\n            try:\n                outcome = json.loads(resp.content)\n            except:\n                outcome = {\"status\": \"success\", \"details\": resp.content}\n        \n        # 记录执行结果\n        log_msg = f\"Action '{action.name}' executed: {outcome['status']}. Confidence: {action.confidence}\"\n        await self._remember(log_msg, type=\"short_term\", relevance_score=0.7)\n        \n        return outcome\n\n    async def evaluate(self, action: Action, outcome: Dict) -> Tuple[float, str]:\n        \"\"\"评估阶段：衡量行动效果，更新信念\"\"\"\n        if not self.context:\n            raise RuntimeError(\"Session not initialized\")\n        \n        self.context.current_thought = ThoughtState.EVALUATE\n        \n        prompt = [\n            {\"role\": \"system\", \"content\": self.system_prompt},\n            {\n                \"role\": \"user\",\n                \"content\": f\"[EVALUATE] Action: {action.name}\\nParameters: {action.parameters}\\nOutcome: {outcome}\\nGoal: {self.context.goal}\\n\\nAssess: (1) How well did this action advance the goal? (2) What was the actual confidence vs expected? (3) What belief should be updated?\\n\\nRespond in JSON: {{'effectiveness_score': 0.0-1.0, 'belief_updates': [...], 'lesson': str}}\"\n            }\n        ]\n        \n        resp = await self._call_openai(prompt)\n        try:\n            eval_result = json.loads(resp.content)\n            score = eval_result.get(\"effectiveness_score\", 0.5)\n            lesson = eval_result.get(\"lesson\", \"No clear lesson\")\n            await self._remember(f\"Evaluation: effectiveness={score}, lesson='{lesson}'\", type=\"long_term\", relevance_score=score)\n            return score, lesson\n        except:\n            return 0.5, \"Evaluation failed; default score applied\"\n\n    async def learn(self) -> str:\n        \"\"\"学习阶段：提炼通用规则，更新内部模型\"\"\"\n        if not self.context:\n            raise RuntimeError(\"Session not initialized\")\n        \n        self.context.current_thought = ThoughtState.LEARN\n        \n        # 提取最近5次行动+评估\n        recent_events = []\n        for i in range(min(5, len(self.context.actions))):\n            action = self.context.actions[-1-i]\n            # 假设我们有对应的评估记录（实际中应关联存储）\n            outcome = {\"status\": \"unknown\"}\n            recent_events.append(f\"Action: {action.name} | Confidence: {action.confidence} | Outcome: {outcome}\")\n        \n        prompt = [\n            {\"role\": \"system\", \"content\": self.system_prompt},\n            {\n                \"role\": \"user\",\n                \"content\": f\"[LEARN] Review these recent experiences:\\n{'\\n'.join(recent_events)}\\n\\nExtract 1-3 generalizable rules or heuristics about: when to trust high-confidence plans, how to handle uncertainty, or domain-specific patterns.\\nFormat as JSON: {{'rules': [{{'condition': str, 'action': str, 'confidence_boost': float}}]}}\"\n            }\n        ]\n        \n        resp = await self._call_openai(prompt)\n        try:\n            rules = json.loads(resp.content).get(\"rules\", [])\n            rule_summary = \" | \".join([r.get(\"condition\", \"?\") for r in rules])\n            await self._remember(f\"Learned rules: {rule_summary}\", type=\"long_term\", relevance_score=0.95)\n            return resp.content\n        except:\n            return \"{\\\"rules\\\":[{\\\"condition\\\":\\\"no learning occurred\\\",\\\"action\\\":\\\"review process\\\",\\\"confidence_boost\\\":0.0}]}\">\n\n    async def run_cycle(self, input_data: str) -> Dict[str, Any]:\n        \"\"\"执行完整认知循环：P-R-P-A-E-L\"\"\"\n        if not self.context:\n            raise RuntimeError(\"Session not initialized. Call initialize_session first.\")\n        \n        logger.info(f\"Starting cognitive cycle for goal: {self.context.goal}\")\n        \n        # 1. Perceive\n        perception = await self.perceive(input_data)\n        \n        # 2. Reflect\n        reflection = await self.reflect()\n        \n        # 3. Plan\n        actions = await self.plan()\n        \n        results = []\n        lessons = []\n        \n        # 4. Act & Evaluate (for each action)\n        for action in actions:\n            outcome = await self.act(action)\n            score, lesson = await self.evaluate(action, outcome)\n            results.append({\"action\": action.dict(), \"outcome\": outcome, \"score\": score})\n            lessons.append(lesson)\n        \n        # 5. Learn\n        learning_output = await self.learn()\n        \n        # 更新上下文时间戳\n        self.context.last_updated = datetime