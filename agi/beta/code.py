# agi

```json
{
    "files": [
        {
            "filename": "agi_system.py",
            "content": "\"\"\"AGI系统主模块\n\n这个模块实现了真正意义上的AGI系统，使用OpenAI API作为核心推理引擎。\nAGI系统具备自主学习、推理、规划和执行的能力。\n\"\"\"\n\nimport os\nimport json\nimport time\nimport logging\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport openai\nfrom openai import OpenAI\nimport numpy as np\nfrom memory_system import MemorySystem\nfrom reasoning_engine import ReasoningEngine\nfrom learning_module import LearningModule\nfrom planning_module import PlanningModule\nfrom execution_module import ExecutionModule\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass AGIState(Enum):\n    \"\"\"AGI系统的状态枚举\"\"\"\n    IDLE = \"idle\"\n    LEARNING = \"learning\"\n    REASONING = \"reasoning\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    ERROR = \"error\"\n\n\n@dataclass\nclass AGIConfig:\n    \"\"\"AGI系统配置类\"\"\"\n    openai_api_key: str = field(default_factory=lambda: os.getenv(\"OPENAI_API_KEY\"))\n    openai_model: str = \"gpt-4-turbo\"\n    max_tokens: int = 4096\n    temperature: float = 0.7\n    memory_capacity: int = 10000\n    learning_rate: float = 0.01\n    reasoning_depth: int = 3\n    planning_horizon: int = 5\n    execution_timeout: int = 300  # 秒\n    verbose: bool = True\n\n\nclass AGISystem:\n    \"\"\"AGI系统主类\n    \n    这个类整合了记忆、推理、学习和执行模块，实现了一个完整的AGI系统。\n    \"\"\"\n    \n    def __init__(self, config: AGIConfig):\n        \"\"\"初始化AGI系统\n        \n        Args:\n            config: AGI系统配置\n        \"\"\"\n        self.config = config\n        self.state = AGIState.IDLE\n        self.client = OpenAI(api_key=config.openai_api_key)\n        \n        # 初始化各个模块\n        self.memory_system = MemorySystem(capacity=config.memory_capacity)\n        self.reasoning_engine = ReasoningEngine(self.client, config)\n        self.learning_module = LearningModule(self.client, config)\n        self.planning_module = PlanningModule(self.client, config)\n        self.execution_module = ExecutionModule(self.client, config)\n        \n        # AGI的知识库和经验\n        self.knowledge_base = {}\n        self.experiences = []\n        self.goals = []\n        self.current_plan = None\n        \n        # 统计信息\n        self.stats = {\n            \"learning_iterations\": 0,\n            \"reasoning_calls\": 0,\n            \"plans_generated\": 0,\n            \"actions_executed\": 0,\n            \"errors\": 0\n        }\n        \n        logger.info(\"AGI系统初始化完成\")\n    \n    def perceive(self, input_data: Dict[str, Any]) -> None:\n        \"\"\"感知外部环境并存储到记忆系统\n        \n        Args:\n            input_data: 感知到的外部数据\n        \"\"\"\n        if self.config.verbose:\n            logger.info(f\"感知到输入数据: {input_data}\")\n        \n        # 将感知数据存储到记忆系统\n        self.memory_system.store_perception(input_data)\n        \n        # 从记忆中检索相关信息\n        relevant_memories = self.memory_system.retrieve_relevant(input_data)\n        \n        # 将感知和相关信息传递给推理引擎\n        self.reason(input_data, relevant_memories)\n    \n    def reason(self, input_data: Dict[str, Any], context: List[Dict] = None) -> Dict[str, Any]:\n        \"\"\"基于输入和上下文进行推理\n        \n        Args:\n            input_data: 输入数据\n            context: 上下文信息\n            \n        Returns:\n            推理结果\n        \"\"\"\n        self.state = AGIState.REASONING\n        \n        if self.config.verbose:\n            logger.info(\"开始推理过程...\")\n        \n        try:\n            # 使用推理引擎进行推理\n            reasoning_result = self.reasoning_engine.reason(\n                input_data=input_data,\n                context=context or [],\n                knowledge_base=self.knowledge_base\n            )\n            \n            self.stats[\"reasoning_calls\"] += 1\n            \n            # 更新知识库\n            self.update_knowledge(reasoning_result)\n            \n            # 根据推理结果决定下一步行动\n            if reasoning_result.get(\"goal\"):\n                self.add_goal(reasoning_result[\"goal\"])\n            \n            if reasoning_result.get(\"action\"):\n                self.execute(reasoning_result[\"action\"])\n            \n            return reasoning_result\n            \n        except Exception as e:\n            self.state = AGIState.ERROR\n            self.stats[\"errors\"] += 1\n            logger.error(f\"推理过程中发生错误: {str(e)}\")\n            return {\"error\": str(e)}\n    \n    def learn(self, experience: Dict[str, Any]) -> None:\n        \"\"\"从经验中学习\n        \n        Args:\n            experience: 学习经验\n        \"\"\"\n        self.state = AGIState.LEARNING\n        \n        if self.config.verbose:\n            logger.info(\"开始学习过程...\")\n        \n        try:\n            # 使用学习模块进行学习\n            learning_result = self.learning_module.learn(\n                experience=experience,\n                knowledge_base=self.knowledge_base,\n                memory_system=self.memory_system\n            )\n            \n            self.stats[\"learning_iterations\"] += 1\n            \n            # 更新知识库\n            self.update_knowledge(learning_result)\n            \n            # 存储经验\n            self.experiences.append(experience)\n            \n            self.state = AGIState.IDLE\n            \n            if self.config.verbose:\n                logger.info(\"学习过程完成\")\n                \n        except Exception as e:\n            self.state = AGIState.ERROR\n            self.stats[\"errors\"] += 1\n            logger.error(f\"学习过程中发生错误: {str(e)}\")\n    \n    def plan(self, goal: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"为实现目标制定计划\n        \n        Args:\n            goal: 目标描述\n            \n        Returns:\n            计划结果\n        \"\"\"\n        self.state = AGIState.PLANNING\n        \n        if self.config.verbose:\n            logger.info(f\"开始为目标制定计划: {goal}\")\n        \n        try:\n            # 使用规划模块制定计划\n            plan = self.planning_module.plan(\n                goal=goal,\n                knowledge_base=self.knowledge_base,\n                memory_system=self.memory_system,\n                current_state=self.get_current_state()\n            )\n            \n            self.stats[\"plans_generated\"] += 1\n            self.current_plan = plan\n            \n            if self.config.verbose:\n                logger.info(\"计划制定完成\")\n                logger.info(f\"计划: {plan}\")\n            \n            return plan\n            \n        except Exception as e:\n            self.state = AGIState.ERROR\n            self.stats[\"errors\"] += 1\n            logger.error(f\"计划制定过程中发生错误: {str(e)}\")\n            return {\"error\": str(e)}\n    \n    def execute(self, action: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"执行行动\n        \n        Args:\n            action: 要执行的行动\n            \n        Returns:\n            执行结果\n        \"\"\"\n        self.state = AGIState.EXECUTING\n        \n        if self.config.verbose:\n            logger.info(f\"开始执行行动: {action}\")\n        \n        try:\n            # 使用执行模块执行行动\n            result = self.execution_module.execute(\n                action=action,\n                knowledge_base=self.knowledge_base,\n                memory_system=self.memory_system\n            )\n            \n            self.stats[\"actions_executed\"] += 1\n            \n            # 从执行结果中学习\n            if result.get(\"success\"):\n                experience = {\n                    \"action\": action,\n                    \"result\": result,\n                    \"timestamp\": time.time(),\n                    \"success\": True\n                }\n                self.learn(experience)\n            \n            self.state = AGIState.IDLE\n            \n            if self.config.verbose:\n                logger.info(\"行动执行完成\")\n                logger.info(f\"结果: {result}\")\n            \n            return result\n            \n        except Exception as e:\n            self.state = AGIState.ERROR\n            self.stats[\"errors\"] += 1\n            logger.error(f\"行动执行过程中发生错误: {str(e)}\")\n            return {\"error\": str(e)}\n    \n    def add_goal(self, goal: Dict[str, Any]) -> None:\n        \"\"\"添加目标\n        \n        Args:\n            goal: 目标描述\n        \"\"\"\n        if goal not in self.goals:\n            self.goals.append(goal)\n            if self.config.verbose:\n                logger.info(f\"添加新目标: {goal}\")\n    \n    def process_goals(self) -> None:\n        \"\"\"处理所有目标，制定并执行计划\"\"\"\n        for goal in self.goals:\n            # 如果没有计划或计划已完成，制定新计划\n            if not self.current_plan or self.is_plan_complete():\n                self.plan(goal)\n            \n            # 执行计划中的下一步\n            if self.current_plan:\n                next_action = self.get_next_action()\n                if next_action:\n                    self.execute(next_action)\n                else:\n                    # 计划完成，从目标列表中移除\n                    self.goals.remove(goal)\n                    self.current_plan = None\n                    logger.info(f\"目标完成: {goal}\")\n    \n    def update_knowledge(self, new_knowledge: Dict[str, Any]) -> None:\n        \"\"\"更新知识库\n        \n        Args:\n            new_knowledge: 新知识\n        \"\"\"\n        for key, value in new_knowledge.items():\n            if key in self.knowledge_base:\n                # 如果知识已存在，进行合并或更新\n                if isinstance(self.knowledge_base[key], dict) and isinstance(value, dict):\n                    self.knowledge_base[key].update(value)\n                else:\n                    self.knowledge_base[key] = value\n            else:\n                # 新知识\n                self.knowledge_base[key] = value\n    \n    def get_current_state(self) -> Dict[str, Any]:\n        \"\"\"获取当前系统状态\n        \n        Returns:\n            当前系统状态\n        \"\"\"\n        return {\n            \"state\": self.state.value,\n            \"goals\": self.goals,\n            \"current_plan\": self.current_plan,\n            \"stats\": self.stats,\n            \"memory_size\": len(self.memory_system.memories)\n        }\n    \n    def is_plan_complete(self) -> bool:\n        \"\"\"检查当前计划是否完成\n        \n        Returns:\n            计划是否完成\n        \"\"\"\n        if not self.current_plan:\n            return True\n        \n        # 简单实现：检查计划中的所有步骤是否都已执行\n        return all(step.get(\"executed\", False) for step in self.current_plan.get(\"steps\", []))\n    \n    def get_next_action(self) -> Optional[Dict[str, Any]]:\n        \"\"\"获取计划中的下一个行动\n        \n        Returns:\n            下一个行动或None（如果没有行动）\n        \"\"\"\n        if not self.current_plan:\n            return None\n        \n        # 找出第一个未执行的步骤\n        for step in self.current_plan.get(\"steps\", []):\n            if not step.get(\"executed\", False):\n                return step\n        \n        return None\n    \n    def run(self, input_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"运行AGI系统的主要循环\n        \n        Args:\n            input_data: 输入数据\n            \n        Returns:\n            系统输出\n        \"\"\"\n        try:\n            # 1. 感知输入\n            self.perceive(input_data)\n            \n            # 2. 处理目标\n            self.process_goals()\n            \n            # 3. 返回当前状态\n            return self.get_current_state()\n            \n        except Exception as e:\n            self.state = AGIState.ERROR\n            self.stats[\"errors\"] += 1\n            logger.error(f\"AGI系统运行过程中发生错误: {str(e)}\")\n            return {\"error\": str(e), \"state\": self.state.value}\n    \n    def save_state(self, filepath: str) -> None:\n        \"\"\"保存AGI系统状态\n        \n        Args:\n            filepath: 保存路径\n        \"\"\"\n        state = {\n            \"knowledge_base\": self.knowledge_base,\n            \"experiences\": self.experiences,\n            \"goals\": self.goals,\n            \"stats\": self.stats,\n            \"config\": self.config.__dict__\n        }\n        \n        with open(filepath, \"w\") as f:\n            json.dump(state, f, indent=2)\n        \n        logger.info(f\"AGI系统状态已保存到 {filepath}\")\n    \n    def load_state(self, filepath: str) -> None:\n        \"\"\"加载AGI系统状态\n        \n        Args:\n            filepath: 加载路径\n        \"\"\"\n        with open(filepath, \"r\") as f:\n            state = json.load(f)\n        \n        self.knowledge_base = state[\"knowledge_base\"]\n        self.experiences = state[\"experiences\"]\n        self.goals = state[\"goals\"]\n        self.stats = state[\"stats\"]\n        \n        # 重新初始化配置\n        self.config = AGIConfig(**state[\"config\"])\n        \n        logger.info(f\"AGI系统状态已从 {filepath} 加载\")\n\n\nif __name__ == \"__main__\":\n    # 示例用法\n    config = AGIConfig(\n        openai_api_key=\"your-openai-api-key\",\n        verbose=True\n    )\n    \n    agi = AGISystem(config)\n    \n    # 示例输入\n    input_data = {\n        \"type\": \"text\",\n        \"content\": \"你好，请介绍一下你自己\"\n    }\n    \n    # 运行AGI系统\n    output = agi.run(input_data)\n    \n    print(\"AGI系统输出:\")\n    print(json.dumps(output, indent=2, ensure_ascii=False))\n"
        },
        {
            "filename": "memory_system.py",
            "content": "\"\"\"记忆系统模块\n\n这个模块实现了AGI的记忆系统，包括短期记忆和长期记忆，\n以及记忆检索和关联功能。\n\"\"\"\n\nimport time\nimport numpy as np\nfrom typing import Dict, List, Any, Optional\nfrom dataclasses import dataclass, field\nimport pickle\nimport os\nimport faiss\nfrom sentence_transformers import SentenceTransformer\n\n\n@dataclass\nclass Memory:\n    \"\"\"记忆数据类\"\"\"\n    content: Dict[str, Any]\n    timestamp: float = field(default_factory=time.time)\n    importance: float = 1.0\n    category: str = \"general\"\n    embedding: Optional[np.ndarray] = None\n    \n    def __post_init__(self):\n        if self.embedding is None:\n            # 使用简单的哈希作为嵌入的替代\n            # 在实际应用中，应该使用更复杂的嵌入方法\n            self.embedding = np.array(hash(str(self.content)) % 1000, dtype=np.float32)\n\n\nclass MemorySystem:\n    \"\"\"记忆系统类\n    \n    这个类实现了AGI的记忆系统，包括记忆存储、检索和关联功能。\n    使用向量索引进行高效的相似性搜索。\n    \"\"\"\n    \n    def __init__(self, capacity: int = 10000, embedding_model: str = \"all-MiniLM-L6-v2\"):\n        \"\"\"初始化记忆系统\n        \n        Args:\n            capacity: 记忆容量\n            embedding_model: 用于生成嵌入的模型名称\n        \"\"\"\n        self.capacity = capacity\n        self.memories: List[Memory] = []\n        self.categories = set()\n        \n        # 初始化向量索引\n        self.embedding_model = SentenceTransformer(embedding_model)\n        self.index = None\n        self.index_initialized = False\n        \n        # 记忆统计\n        self.stats = {\n            \"total_memories\": 0,\n            \"memories_by_category\": {},\n            \"average_importance\": 0.0,\n            \"oldest_memory\": None,\n            \"newest_memory\": None\n        }\n    \n    def store_perception(self