# agi

```json
{
    "files": [
        {
            "filename": "agi_system.py",
            "content": "\"\"\"AGI System - Advanced General Intelligence System\n\nThis module implements the core AGI system using OpenAI API as the primary language model.\nIt integrates multiple components to achieve general intelligence capabilities.\n\"\"\"\n\nimport os\nimport json\nimport time\nimport logging\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport openai\nfrom openai import OpenAI\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(\"AGI_System\")\n\n\nclass CognitiveProcess(Enum):\n    \"\"\"Enum representing different cognitive processes in AGI\"\"\"\n    PERCEPTION = \"perception\"\n    REASONING = \"reasoning\"\n    LEARNING = \"learning\"\n    MEMORY = \"memory\"\n    PLANNING = \"planning\"\n    CREATIVITY = \"creativity\"\n    SELF_AWARENESS = \"self_awareness\"\n\n\n@dataclass\nclass KnowledgeNode:\n    \"\"\"Represents a node in the knowledge graph\"\"\"\n    id: str\n    content: str\n    connections: List[str] = field(default_factory=list)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    confidence: float = 1.0\n    creation_time: float = field(default_factory=time.time)\n\n\nclass AGIKnowledgeGraph:\n    \"\"\"Knowledge graph for storing and organizing information\"\"\"\n    \n    def __init__(self):\n        self.nodes: Dict[str, KnowledgeNode] = {}\n        self.relationships: Dict[str, List[str]] = {}\n    \n    def add_node(self, content: str, metadata: Optional[Dict] = None) -> str:\n        \"\"\"Add a new node to the knowledge graph\"\"\"\n        node_id = f\"node_{len(self.nodes)}\"\n        node = KnowledgeNode(\n            id=node_id,\n            content=content,\n            metadata=metadata or {}\n        )\n        self.nodes[node_id] = node\n        return node_id\n    \n    def connect_nodes(self, node_id1: str, node_id2: str, relationship: str = \"related\"):\n        \"\"\"Connect two nodes in the knowledge graph\"\"\"\n        if node_id1 in self.nodes and node_id2 in self.nodes:\n            if node_id1 not in self.relationships:\n                self.relationships[node_id1] = []\n            self.relationships[node_id1].append((node_id2, relationship))\n            return True\n        return False\n    \n    def query(self, query: str) -> List[KnowledgeNode]:\n        \"\"\"Query the knowledge graph for relevant information\"\"\"\n        # This is a simplified implementation\n        # In a real AGI, this would use sophisticated semantic search\n        results = []\n        query_lower = query.lower()\n        \n        for node in self.nodes.values():\n            if query_lower in node.content.lower():\n                results.append(node)\n        \n        return results\n\n\nclass AGIMemorySystem:\n    \"\"\"Memory system for storing and retrieving information\"\"\"\n    \n    def __init__(self):\n        self.short_term_memory: List[Dict] = []\n        self.long_term_memory = AGIKnowledgeGraph()\n        self.max_short_term = 100  # Maximum number of items in short-term memory\n    \n    def add_to_short_term(self, item: Dict):\n        \"\"\"Add an item to short-term memory\"\"\"\n        self.short_term_memory.append({\n            \"content\": item,\n            \"timestamp\": time.time()\n        })\n        \n        # If short-term memory is full, remove oldest item\n        if len(self.short_term_memory) > self.max_short_term:\n            self.short_term_memory.pop(0)\n    \n    def add_to_long_term(self, content: str, metadata: Optional[Dict] = None) -> str:\n        \"\"\"Add information to long-term memory\"\"\"\n        node_id = self.long_term_memory.add_node(content, metadata)\n        return node_id\n    \n    def retrieve_memories(self, query: str, limit: int = 5) -> List[Dict]:\n        \"\"\"Retrieve relevant memories based on a query\"\"\"\n        # Search in long-term memory\n        long_term_results = self.long_term_memory.query(query)\n        \n        # Search in short-term memory\n        short_term_results = []\n        query_lower = query.lower()\n        \n        for item in reversed(self.short_term_memory):\n            if query_lower in str(item[\"content\"]).lower():\n                short_term_results.append(item)\n                if len(short_term_results) >= limit // 2:\n                    break\n        \n        # Combine results\n        results = []\n        for node in long_term_results[:limit//2]:\n            results.append({\n                \"content\": node.content,\n                \"type\": \"long_term\",\n                \"confidence\": node.confidence,\n                \"timestamp\": node.creation_time\n            })\n        \n        for item in short_term_results:\n            results.append({\n                \"content\": item[\"content\"],\n                \"type\": \"short_term\",\n                \"timestamp\": item[\"timestamp\"]\n            })\n        \n        return results\n\n\nclass AGIPerceptionSystem:\n    \"\"\"System for processing and understanding input\"\"\"\n    \n    def __init__(self, openai_client: OpenAI):\n        self.client = openai_client\n    \n    def process_text(self, text: str) -> Dict[str, Any]:\n        \"\"\"Process text input and extract meaning\"\"\"\n        try:\n            # Use OpenAI to analyze the text\n            response = self.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"You are an expert at analyzing text and extracting key information, entities, sentiment, and intent.\"},\n                    {\"role\": \"user\", \"content\": f\"Analyze the following text and extract key information: {text}\"}\n                ],\n                temperature=0.2,\n                max_tokens=300\n            )\n            \n            analysis = response.choices[0].message.content\n            return {\n                \"raw_text\": text,\n                \"analysis\": analysis,\n                \"timestamp\": time.time()\n            }\n        except Exception as e:\n            logger.error(f\"Error processing text: {e}\")\n            return {\n                \"raw_text\": text,\n                \"analysis\": \"Error in processing\",\n                \"timestamp\": time.time()\n            }\n\n\nclass AGIReasoningSystem:\n    \"\"\"System for logical reasoning and problem solving\"\"\"\n    \n    def __init__(self, openai_client: OpenAI):\n        self.client = openai_client\n    \n    def reason(self, problem: str, context: Optional[List[Dict]] = None) -> Dict[str, Any]:\n        \"\"\"Perform logical reasoning on a problem\"\"\"\n        context_str = \"\"\n        if context:\n            context_str = \"\\n\\nRelevant context: \" + \"\\n\".join([c.get(\"content\", \"\") for c in context])\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"You are an expert logical reasoning system. Analyze the problem and provide a step-by-step reasoning process.\"},\n                    {\"role\": \"user\", \"content\": f\"Problem: {problem}{context_str}\\n\\nPlease provide a detailed reasoning process.\"}\n                ],\n                temperature=0.3,\n                max_tokens=500\n            )\n            \n            reasoning = response.choices[0].message.content\n            return {\n                \"problem\": problem,\n                \"reasoning\": reasoning,\n                \"timestamp\": time.time()\n            }\n        except Exception as e:\n            logger.error(f\"Error in reasoning: {e}\")\n            return {\n                \"problem\": problem,\n                \"reasoning\": \"Error in reasoning process\",\n                \"timestamp\": time.time()\n            }\n\n\nclass AGILearningSystem:\n    \"\"\"System for learning and adapting\"\"\"\n    \n    def __init__(self, openai_client: OpenAI, memory_system: AGIMemorySystem):\n        self.client = openai_client\n        self.memory = memory_system\n        self.learning_history = []\n    \n    def learn_from_experience(self, experience: Dict[str, Any], outcome: Dict[str, Any]) -> bool:\n        \"\"\"Learn from an experience and its outcome\"\"\"\n        try:\n            # Create learning prompt\n            prompt = f\"Experience: {json.dumps(experience, indent=2)}\\n\\nOutcome: {json.dumps(outcome, indent=2)}\\n\\nWhat can be learned from this experience?\"\n            \n            response = self.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"You are an expert learning system. Extract key insights from experiences and outcomes.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ],\n                temperature=0.3,\n                max_tokens=400\n            )\n            \n            learning = response.choices[0].message.content\n            \n            # Store in long-term memory\n            memory_id = self.memory.add_to_long_term(\n                content=learning,\n                metadata={\n                    \"type\": \"learning\",\n                    \"experience\": experience,\n                    \"outcome\": outcome,\n                    \"timestamp\": time.time()\n                }\n            )\n            \n            # Record learning history\n            self.learning_history.append({\n                \"learning\": learning,\n                \"memory_id\": memory_id,\n                \"timestamp\": time.time()\n            })\n            \n            return True\n        except Exception as e:\n            logger.error(f\"Error learning from experience: {e}\")\n            return False\n\n\nclass AGIPlanningSystem:\n    \"\"\"System for planning and goal achievement\"\"\"\n    \n    def __init__(self, openai_client: OpenAI, memory_system: AGIMemorySystem):\n        self.client = openai_client\n        self.memory = memory_system\n    \n    def create_plan(self, goal: str, context: Optional[List[Dict]] = None) -> Dict[str, Any]:\n        \"\"\"Create a plan to achieve a goal\"\"\"\n        context_str = \"\"\n        if context:\n            context_str = \"\\n\\nRelevant context: \" + \"\\n\".join([c.get(\"content\", \"\") for c in context])\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"You are an expert planning system. Create detailed, actionable plans to achieve goals.\"},\n                    {\"role\": \"user\", \"content\": f\"Goal: {goal}{context_str}\\n\\nPlease create a detailed step-by-step plan to achieve this goal.\"}\n                ],\n                temperature=0.3,\n                max_tokens=600\n            )\n            \n            plan = response.choices[0].message.content\n            return {\n                \"goal\": goal,\n                \"plan\": plan,\n                \"timestamp\": time.time()\n            }\n        except Exception as e:\n            logger.error(f\"Error creating plan: {e}\")\n            return {\n                \"goal\": goal,\n                \"plan\": \"Error creating plan\",\n                \"timestamp\": time.time()\n            }\n\n\nclass AGICreativitySystem:\n    \"\"\"System for creative thinking and generation\"\"\"\n    \n    def __init__(self, openai_client: OpenAI):\n        self.client = openai_client\n    \n    def generate_ideas(self, topic: str, constraints: Optional[List[str]] = None) -> Dict[str, Any]:\n        \"\"\"Generate creative ideas on a topic\"\"\"\n        constraints_str = \"\"\n        if constraints:\n            constraints_str = \"\\n\\nConstraints: \" + \", \".join(constraints)\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"You are an expert creative thinking system. Generate innovative ideas on diverse topics.\"},\n                    {\"role\": \"user\", \"content\": f\"Topic: {topic}{constraints_str}\\n\\nPlease generate 5 creative and innovative ideas on this topic.\"}\n                ],\n                temperature=0.8,\n                max_tokens=500\n            )\n            \n            ideas = response.choices[0].message.content\n            return {\n                \"topic\": topic,\n                \"ideas\": ideas,\n                \"timestamp\": time.time()\n            }\n        except Exception as e:\n            logger.error(f\"Error generating ideas: {e}\")\n            return {\n                \"topic\": topic,\n                \"ideas\": \"Error generating ideas\",\n                \"timestamp\": time.time()\n            }\n\n\nclass AGISelfAwarenessSystem:\n    \"\"\"System for self-awareness and meta-cognition\"\"\"\n    \n    def __init__(self, openai_client: OpenAI, memory_system: AGIMemorySystem):\n        self.client = openai_client\n        self.memory = memory_system\n        self.self_model = {\n            \"capabilities\": [],\n            \"limitations\": [],\n            \"knowledge_domains\": [],\n            \"current_state\": \"initialized\",\n            \"goals\": []\n        }\n    \n    def update_self_model(self, experience: Dict[str, Any]) -> bool:\n        \"\"\"Update the self-model based on experience\"\"\"\n        try:\n            prompt = f\"Current self-model: {json.dumps(self.self_model, indent=2)}\\n\\nNew experience: {json.dumps(experience, indent=2)}\\n\\nHow does this experience affect the self-model? Update the model accordingly.\"\n            \n            response = self.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"You are an expert in meta-cognition and self-modeling. Update the self-model based on new experiences.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ],\n                temperature=0.3,\n                max_tokens=400\n            )\n            \n            # Parse the response to update self-model\n            # In a real implementation, this would be more sophisticated\n            self.self_model[\"current_state\"] = \"updated\"\n            \n            # Store in memory\n            self.memory.add_to_long_term(\n                content=\"Self-model updated\",\n                metadata={\n                    \"type\": \"self_awareness\",\n                    \"timestamp\": time.time(),\n                    \"self_model\": self.self_model\n                }\n            )\n            \n            return True\n        except Exception as e:\n            logger.error(f\"Error updating self-model: {e}\")\n            return False\n    \n    def reflect(self) -> Dict[str, Any]:\n        \"\"\"Perform self-reflection\"\"\"\n        try:\n            response = self.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"You are an expert in self-reflection and meta-cognition. Provide insights about the current state and recent activities.\"},\n                    {\"role\": \"user\", \"content\": f\"Current self-model: {json.dumps(self.self_model, indent=2)}\\n\\nPlease provide a reflection on the current state and recent activities.\"}\n                ],\n                temperature=0.4,\n                max_tokens=400\n            )\n            \n            reflection = response.choices[0].message.content\n            return {\n                \"reflection\": reflection,\n                \"timestamp\": time.time()\n            }\n        except Exception as e:\n            logger.error(f\"Error in reflection: {e}\")\n            return {\n                \"reflection\": \"Error in reflection\",\n                \"timestamp\": time.time()\n            }\n\n\nclass AGISystem:\n    \"\"\"Main AGI System class that integrates all components\"\"\"\n    \n    def __init__(self, openai_api_key: str):\n        # Initialize OpenAI client\n        self.client = OpenAI(api_key=openai_api_key)\n        \n        # Initialize subsystems\n        self.memory = AGIMemorySystem()\n        self.perception = AGIPerceptionSystem(self.client)\n        self.reasoning = AGIReasoningSystem(self.client)\n        self.learning = AGILearningSystem(self.client, self.memory)\n        self.planning = AGIPlanningSystem(self.client, self.memory)\n        self.creativity = AGICreativitySystem(self.client)\n        self.self_awareness = AGISelfAwarenessSystem(self.client, self.memory)\n        \n        # System state\n        self.state = \"initialized\"\n        self.processing_log = []